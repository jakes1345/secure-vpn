#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PhazeBrowser Enhanced - VPN-Native Secure Browser with Privacy Features
A custom browser that routes ALL traffic through the VPN with built-in privacy
"""

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('WebKit2', '4.1')

from gi.repository import Gtk, WebKit2, GLib, Gdk
import subprocess
import threading
import time
from pathlib import Path
import os
import sys
import json
from datetime import datetime

# Try to import requests for downloading configs
try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    print("‚ö†Ô∏è requests module not found. Install with: pip3 install requests")

class PhazeBrowserEnhanced:
    def __init__(self):
        self.window = Gtk.Window()
        self.window.set_title("PhazeBrowser - Secure VPN Browser")
        self.window.set_default_size(1400, 900)
        self.window.connect("destroy", Gtk.main_quit)
        
        # VPN status
        self.vpn_connected = False
        self.vpn_interface = None
        self.vpn_process = None
        self.vpn_client_name = None
        self.vpn_protocol = None
        self.check_vpn_interval = 2
        self.vpn_connection_start_time = None
        self.vpn_session_bytes_sent = 0
        self.vpn_session_bytes_received = 0
        self.vpn_latency = None
        self.vpn_server_ip = None
        self.web_portal_session = None  # Store session cookies for API calls
        self.auto_reconnect_enabled = True
        self.kill_switch_enabled = False
        
        # VPN configs directory
        self.vpn_configs_dir = Path.home() / "Downloads"
        self.vpn_configs_dir.mkdir(exist_ok=True)
        
        # Browser state
        self.tabs = []
        self.current_tab = None
        self.bookmarks = self.load_bookmarks()
        self.history = self.load_history()
        self.downloads = []  # Download manager
        self.saved_passwords = self.load_passwords()  # Password manager
        
        # Privacy settings - COMPLETE GHOST MODE
        self.settings = {
            'ad_blocking': True,
            'tracking_protection': True,
            'fingerprint_protection': True,
            'webrtc_leak_protection': True,
            'dns_over_https': True,
            'theme': 'default',
            'max_privacy_mode': True,
            'ghost_mode': True,  # Complete invisibility
            'block_all_cookies': True,  # Block ALL cookies (not just third-party)
            'block_all_scripts': False,  # Too aggressive, but option available
            'block_all_images': False,  # Too aggressive, but option available
            'block_all_fonts': True,  # Prevent font fingerprinting
            'block_all_plugins': True,
            'block_geolocation': True,
            'block_notifications': True,
            'block_camera': True,
            'block_microphone': True,
            'block_battery_api': True,
            'block_bluetooth': True,
            'block_usb': True,
            'block_serial': True,
            'block_hid': True,
        }
        
        # Privacy stats - track what we block
        self.privacy_stats = {
            'ads_blocked': 0,
            'trackers_blocked': 0,
            'cookies_blocked': 0,
            'scripts_blocked': 0,
            'fingerprints_prevented': 0,
            'requests_blocked': 0,
            'domains_blocked': set(),
        }
        
        # Opera GX Gaming Mode
        self.gaming_mode = False
        self.cpu_limit = 100  # Percentage
        self.ram_limit = 100  # Percentage
        self.network_limit = 100  # Percentage
        
        # Firefox Container Tabs
        self.container_tabs = {}  # tab_id -> container_name
        self.containers = ['Personal', 'Work', 'Banking', 'Shopping']
        
        # Vivaldi Features
        self.sidebar_visible = False
        self.tab_stacks = {}  # Stacked tabs
        self.notes = []
        self.web_panels = []
        
        # Brave Features
        self.bat_rewards_enabled = False
        self.shields_level = 'aggressive'  # aggressive, balanced, standard
        
        # Safari Features
        self.tab_groups = {}
        self.reader_mode_available = False
        self.shared_with_you = []
        
        # Filter lists cache
        self.filter_lists_loaded = False
        self.easylist_rules = []
        self.easyprivacy_rules = []
        self.blocked_domains = set()
        
        # Load filter lists in background
        if REQUESTS_AVAILABLE:
            threading.Thread(target=self.load_filter_lists, daemon=True).start()
        
        # Check VPN status
        self.check_vpn_status()
        
        # Create UI
        self.create_ui()
        
        # Apply CSS styling
        self.apply_css_styling()
        
        # Start VPN monitoring
        self.start_vpn_monitoring()
    
    def load_bookmarks(self):
        """Load bookmarks from file"""
        bookmarks_file = Path.home() / ".config" / "phazebrowser" / "bookmarks.json"
        if bookmarks_file.exists():
            try:
                return json.load(open(bookmarks_file))
            except:
                return []
        return []
    
    def save_bookmarks(self):
        """Save bookmarks to file"""
        bookmarks_file = Path.home() / ".config" / "phazebrowser" / "bookmarks.json"
        bookmarks_file.parent.mkdir(parents=True, exist_ok=True)
        json.dump(self.bookmarks, open(bookmarks_file, 'w'), indent=2)
    
    def load_history(self):
        """Load browsing history"""
        history_file = Path.home() / ".config" / "phazebrowser" / "history.json"
        if history_file.exists():
            try:
                return json.load(open(history_file))
            except:
                return []
        return []
    
    def load_passwords(self):
        """Load saved passwords"""
        passwords_file = Path.home() / ".config" / "phazebrowser" / "passwords.json"
        if passwords_file.exists():
            try:
                return json.load(open(passwords_file))
            except:
                return []
        return []
    
    def save_passwords(self):
        """Save passwords to file"""
        passwords_file = Path.home() / ".config" / "phazebrowser" / "passwords.json"
        passwords_file.parent.mkdir(parents=True, exist_ok=True)
        json.dump(self.saved_passwords, open(passwords_file, 'w'), indent=2)
    
    def save_history(self, url, title=""):
        """Save to browsing history"""
        self.history.insert(0, {
            'url': url,
            'title': title,
            'timestamp': datetime.now().isoformat()
        })
        # Keep last 1000 entries
        self.history = self.history[:1000]
        
        history_file = Path.home() / ".config" / "phazebrowser" / "history.json"
        history_file.parent.mkdir(parents=True, exist_ok=True)
        json.dump(self.history, open(history_file, 'w'), indent=2)
    
    def check_vpn_status(self):
        """Check if VPN is connected"""
        try:
            result = subprocess.run(['ip', 'link', 'show'], 
                                  capture_output=True, text=True, timeout=2)
            
            for line in result.stdout.split('\n'):
                if 'tun' in line.lower() and 'state UP' in line:
                    parts = line.split(':')
                    if len(parts) >= 2:
                        self.vpn_interface = parts[1].strip().split()[0]
                        self.vpn_connected = True
                        return True
            
            result = subprocess.run(['pgrep', '-f', 'openvpn'], 
                                  capture_output=True, text=True, timeout=2)
            if result.returncode == 0:
                result = subprocess.run(['ip', 'addr', 'show'], 
                                      capture_output=True, text=True, timeout=2)
                if 'tun' in result.stdout:
                    self.vpn_connected = True
                    for line in result.stdout.split('\n'):
                        if 'tun' in line and 'inet' in line:
                            parts = line.split()
                            for i, part in enumerate(parts):
                                if 'tun' in part:
                                    self.vpn_interface = part
                                    break
                    return True
            
            self.vpn_connected = False
            self.vpn_interface = None
            return False
            
        except Exception as e:
            print(f"Error checking VPN status: {e}")
            self.vpn_connected = False
            return False
    
    def start_vpn_monitoring(self):
        """Start monitoring VPN connection"""
        def monitor():
            while True:
                was_connected = self.vpn_connected
                self.check_vpn_status()
                
                if was_connected != self.vpn_connected:
                    GLib.idle_add(self.update_vpn_status)
                
                time.sleep(self.check_vpn_interval)
        
        thread = threading.Thread(target=monitor, daemon=True)
        thread.start()
    
    def update_vpn_status(self):
        """Update VPN status in UI"""
        if self.vpn_connected:
            # Update connection time
            if self.vpn_connection_start_time:
                elapsed = time.time() - self.vpn_connection_start_time
                hours = int(elapsed // 3600)
                minutes = int((elapsed % 3600) // 60)
                time_str = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"
            else:
                time_str = "Connected"
            
            # Update stats
            self.update_vpn_stats()
            
            status_text = f"üü¢ VPN Connected ({self.vpn_interface or 'Active'}) - {time_str}"
            if self.vpn_latency:
                status_text += f" | {self.vpn_latency}ms"
            self.vpn_status_label.set_text(status_text)
            self.vpn_status_label.set_name("vpn-connected")
            self.vpn_connect_btn.set_label("üî¥ Disconnect VPN")
            self.vpn_stats_btn.set_sensitive(True)
            if self.current_tab:
                self.current_tab['webview'].set_sensitive(True)
        else:
            self.vpn_status_label.set_text("üî¥ VPN Disconnected - Browsing Blocked")
            self.vpn_status_label.set_name("vpn-disconnected")
            self.vpn_connect_btn.set_label("üîå Connect VPN")
            self.vpn_stats_btn.set_sensitive(False)
            if self.current_tab:
                self.current_tab['webview'].set_sensitive(False)
                if not self.vpn_process:  # Only show warning if not trying to connect
                    self.show_vpn_warning()
            
            # Auto-reconnect if enabled
            if self.auto_reconnect_enabled and self.vpn_client_name and not self.vpn_process:
                GLib.timeout_add(5000, self.attempt_auto_reconnect)
    
    def update_vpn_stats(self):
        """Update VPN connection statistics"""
        if not self.vpn_connected or not self.vpn_interface:
            return
        
        try:
            # Get interface stats
            result = subprocess.run(['ip', '-s', 'link', 'show', self.vpn_interface],
                                  capture_output=True, text=True, timeout=2)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for i, line in enumerate(lines):
                    if 'RX:' in line and i + 1 < len(lines):
                        # Parse received bytes
                        rx_line = lines[i + 1].strip()
                        if 'bytes' in rx_line:
                            try:
                                self.vpn_session_bytes_received = int(rx_line.split()[0])
                            except:
                                pass
                    if 'TX:' in line and i + 1 < len(lines):
                        # Parse sent bytes
                        tx_line = lines[i + 1].strip()
                        if 'bytes' in tx_line:
                            try:
                                self.vpn_session_bytes_sent = int(tx_line.split()[0])
                            except:
                                pass
            
            # Measure latency (ping VPN server)
            if self.vpn_server_ip:
                result = subprocess.run(['ping', '-c', '1', '-W', '1', self.vpn_server_ip],
                                      capture_output=True, text=True, timeout=3)
                if result.returncode == 0:
                    # Extract latency from ping output
                    for line in result.stdout.split('\n'):
                        if 'time=' in line:
                            try:
                                latency_str = line.split('time=')[1].split()[0]
                                self.vpn_latency = int(float(latency_str))
                            except:
                                pass
        except:
            pass  # Silently fail stats update
    
    def attempt_auto_reconnect(self):
        """Attempt to automatically reconnect VPN"""
        if self.vpn_connected or not self.vpn_client_name:
            return False
        
        # Find config file
        config_file = None
        if self.vpn_protocol == "openvpn":
            config_file = self.vpn_configs_dir / f"{self.vpn_client_name}.ovpn"
        elif self.vpn_protocol == "wireguard":
            config_file = self.vpn_configs_dir / f"{self.vpn_client_name}.conf"
        
        if config_file and config_file.exists():
            print("üîÑ Auto-reconnecting VPN...")
            self.connect_vpn(config_file, self.vpn_protocol, self.vpn_client_name)
        
        return False  # Don't repeat
    
    def show_vpn_warning(self):
        """Show warning page when VPN is disconnected"""
        warning_html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>VPN Required - PhazeBrowser</title>
            <style>
                body {
                    font-family: Arial, sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 100vh;
                    margin: 0;
                    text-align: center;
                }
                .container {
                    background: rgba(0,0,0,0.3);
                    padding: 40px;
                    border-radius: 20px;
                    max-width: 600px;
                }
                h1 { font-size: 48px; margin: 0 0 20px 0; }
                p { font-size: 18px; line-height: 1.6; }
                .icon { font-size: 80px; margin-bottom: 20px; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="icon">üîí</div>
                <h1>VPN Required</h1>
                <p>PhazeBrowser requires an active VPN connection to protect your privacy.</p>
                <p>Please connect to your VPN and refresh this page.</p>
                <p><strong>Your browsing is blocked until VPN is connected.</strong></p>
            </div>
        </body>
        </html>
        """
        if self.current_tab:
            self.current_tab['webview'].load_html(warning_html, "file:///")
    
    def create_webview_settings(self):
        """Create WebKit settings with COMPLETE GHOST MODE privacy"""
        settings = WebKit2.Settings()
        
        # COMPLETE GHOST MODE - Block everything
        settings.set_property("enable-javascript", not self.settings.get('block_all_scripts', False))
        settings.set_property("enable-plugins", False)  # Always disable plugins
        settings.set_property("enable-java", False)
        
        # Block media access completely
        if self.settings.get('block_camera', True) or self.settings.get('block_microphone', True):
            settings.set_property("enable-media-stream", False)
        
        # Block WebAudio (fingerprinting)
        if self.settings.get('fingerprint_protection', True):
            settings.set_property("enable-webaudio", False)
        
        # Block all fonts (font fingerprinting) - handled via CSS injection in create_webview
        
        # WebRTC - VPN handles at system level, but we can disable browser-level too
        if self.settings.get('webrtc_leak_protection', True):
            # System-level VPN routing ensures WebRTC goes through VPN
            pass
        
        return settings
    
    def create_webview(self):
        """Create a new WebView with privacy settings"""
        settings = self.create_webview_settings()
        
        # User content manager for comprehensive ad blocking and tracking protection
        user_content = WebKit2.UserContentManager()
        
        # Maximum privacy mode - make all users identical (anti-fingerprinting)
        if self.settings.get('max_privacy_mode', True):
            max_privacy_js = self.load_max_privacy_mode_js()
            user_content.add_script(
                WebKit2.UserScript(max_privacy_js,
                                 WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                                 WebKit2.UserScriptInjectionTime.START,
                                 None, None)
            )
        
        # Comprehensive ad blocking
        if self.settings['ad_blocking']:
            # CSS-based ad blocking
            ad_block_css = self.load_ad_block_css()
            user_content.add_style_sheet(
                WebKit2.UserStyleSheet(ad_block_css, 
                                     WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                                     WebKit2.UserScriptInjectionTime.START,
                                     None, None)
            )
            
            # JavaScript-based ad blocking (runs before page loads)
            ad_block_js = self.load_comprehensive_ad_block_js()
            user_content.add_script(
                WebKit2.UserScript(ad_block_js,
                                 WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                                 WebKit2.UserScriptInjectionTime.START,
                                 None, None)
            )
        
        # Comprehensive tracking protection
        if self.settings['tracking_protection']:
            # Network-level tracking block
            tracking_block_js = self.load_comprehensive_tracking_block_js()
            user_content.add_script(
                WebKit2.UserScript(tracking_block_js,
                                 WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                                 WebKit2.UserScriptInjectionTime.START,
                                 None, None)
            )
            
            # COMPLETE GHOST MODE - Block ALL cookies
            cookie_block_js = self.load_cookie_blocking_js()
            user_content.add_script(
                WebKit2.UserScript(cookie_block_js,
                                 WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                                 WebKit2.UserScriptInjectionTime.START,
                                 None, None)
            )
            
            # Block font loading (font fingerprinting)
            if self.settings.get('block_all_fonts', True):
                font_block_css = """
                @font-face {
                    font-family: 'blocked' !important;
                }
                * {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
                }
                """
                user_content.add_style_sheet(
                    WebKit2.UserStyleSheet(font_block_css,
                                         WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                                         WebKit2.UserScriptInjectionTime.START,
                                         None, None)
                )
        
        # Fingerprinting protection
        if self.settings['fingerprint_protection']:
            fingerprint_block_js = self.load_fingerprint_protection_js()
            user_content.add_script(
                WebKit2.UserScript(fingerprint_block_js,
                                 WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                                 WebKit2.UserScriptInjectionTime.START,
                                 None, None)
            )
        
        # Create WebView with UserContentManager (must be passed to constructor)
        webview = WebKit2.WebView.new_with_user_content_manager(user_content)
        webview.set_settings(settings)
        
        # Connect to request filtering signal for network-level blocking (on WebView, not UserContentManager)
        webview.connect("decide-policy", self.on_decide_policy)
        
        # Connect to resource load signals for additional blocking
        webview.connect("resource-load-started", self.on_resource_load_started)
        
        # Connect signals
        webview.connect("load-changed", self.on_load_changed)
        webview.connect("notify::title", self.on_title_changed)
        
        # Note: Downloads are handled via WebContext, not WebView signals
        # We'll handle downloads through the context if needed
        
        return webview
    
    def apply_css_styling(self):
        """Apply modern, polished CSS styling to the browser"""
        theme = self.settings.get('theme', 'default')
        
        if theme == 'dark':
            css = """
            * {
                font-family: 'Inter', 'Segoe UI', 'Ubuntu', 'Cantarell', sans-serif;
            }
            
            window {
                background-color: #1e1e1e;
            }
            
            /* VPN Status Bar - Modern gradient */
            box {
                background-color: #667eea;
                border-bottom: 2px solid #555;
                padding: 8px;
            }
            
            button {
                background-color: #667eea;
                color: white;
                border: none;
                border-radius: 8px;
                padding: 8px 16px;
                font-weight: 600;
            }
            
            button:hover {
                background-color: #764ba2;
            }
            
            button:active {
                background-color: #667eea;
            }
            
            entry {
                background-color: #3c3c3c;
                color: #e0e0e0;
                border: 2px solid rgba(255,255,255,0.2);
                border-radius: 12px;
                padding: 10px 15px;
            }
            
            entry:focus {
                border-color: #667eea;
                background-color: #4a4a4a;
            }
            
            notebook {
                background: #1e1e1e;
            }
            
            notebook tab {
                background-color: #2b2b2b;
                color: #b0b0b0;
                border-radius: 12px 12px 0 0;
                padding: 10px 20px;
                margin: 0 2px;
                border: 1px solid rgba(255,255,255,0.1);
                border-bottom: none;
                font-weight: 500;
            }
            
            notebook tab:hover {
                background-color: #333;
                color: #fff;
            }
            
            notebook tab:checked {
                background-color: #667eea;
                color: white;
                border-color: #667eea;
            }
            
            .vpn-connected {
                color: #2ecc71;
                font-weight: bold;
            }
            
            .vpn-disconnected {
                color: #e74c3c;
                font-weight: bold;
            }
            
            label {
                color: #e0e0e0;
            }
            """
        elif theme == 'light':
            css = """
            * {
                font-family: 'Inter', 'Segoe UI', 'Ubuntu', 'Cantarell', sans-serif;
            }
            
            window {
                background-color: #ffffff;
            }
            
            /* VPN Status Bar - Modern gradient */
            box {
                background-color: #667eea;
                border-bottom: 2px solid #ddd;
                padding: 8px;
            }
            
            button {
                background-color: #667eea;
                color: white;
                border: none;
                border-radius: 8px;
                padding: 8px 16px;
                font-weight: 600;
            }
            
            button:hover {
                background-color: #764ba2;
            }
            
            entry {
                background-color: #ffffff;
                color: #333;
                border: 2px solid #e0e0e0;
                border-radius: 12px;
                padding: 10px 15px;
            }
            
            entry:focus {
                border-color: #667eea;
                background-color: #ffffff;
            }
            
            notebook {
                background-color: #ffffff;
            }
            
            notebook tab {
                background-color: #f5f5f5;
                color: #666;
                border-radius: 12px 12px 0 0;
                padding: 10px 20px;
                margin: 0 2px;
                border: 1px solid #e0e0e0;
                border-bottom: none;
                font-weight: 500;
            }
            
            notebook tab:hover {
                background-color: #e8e8e8;
                color: #333;
            }
            
            notebook tab:checked {
                background-color: #667eea;
                color: white;
                border-color: #667eea;
            }
            
            .vpn-connected {
                color: #2ecc71;
                font-weight: bold;
            }
            
            .vpn-disconnected {
                color: #e74c3c;
                font-weight: bold;
            }
            
            label {
                color: #333;
            }
            """
        else:  # default - FRANKENSTEIN MODERN THEME (Safari + Chrome + Opera GX + Vivaldi + Brave)
            css = """
            * {
                font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', 'Roboto', 'Inter', 'Ubuntu', sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }
            
            window {
                background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
                background-color: #0f0f23;
            }
            
            /* VPN Status Bar - Glassmorphism (Safari-inspired) */
            box {
                background: rgba(102, 126, 234, 0.15);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding: 14px 20px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            
            label {
                color: rgba(255, 255, 255, 0.95);
                font-weight: 500;
                letter-spacing: 0.3px;
            }
            
            /* VPN status styling - Modern badges */
            .vpn-connected {
                color: #00ff88;
                font-weight: 700;
                font-size: 13px;
                text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
                letter-spacing: 0.5px;
            }
            
            .vpn-disconnected {
                color: #ff4757;
                font-weight: 700;
                font-size: 13px;
                text-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
                letter-spacing: 0.5px;
            }
            
            /* Modern buttons - Opera GX style with glow */
            button {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 12px;
                padding: 12px 24px;
                font-weight: 600;
                font-size: 13px;
                letter-spacing: 0.3px;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4),
                            0 0 20px rgba(102, 126, 234, 0.2);
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
            
            button:hover {
                background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6),
                            0 0 30px rgba(102, 126, 234, 0.4);
            }
            
            button:active {
                transform: translateY(0px);
                box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
            }
            
            /* Modern URL bar - Chrome-inspired with glassmorphism */
            entry {
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                color: rgba(255, 255, 255, 0.95);
                border: 2px solid rgba(255, 255, 255, 0.15);
                border-radius: 24px;
                padding: 14px 24px;
                font-size: 14px;
                font-weight: 400;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2),
                            inset 0 1px 0 rgba(255, 255, 255, 0.1);
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }
            
            entry:focus {
                border-color: rgba(102, 126, 234, 0.8);
                background: rgba(255, 255, 255, 0.15);
                box-shadow: 0 6px 30px rgba(102, 126, 234, 0.4),
                            inset 0 1px 0 rgba(255, 255, 255, 0.2),
                            0 0 0 3px rgba(102, 126, 234, 0.2);
            }
            
            /* Modern tabs - Vivaldi-inspired with stacking effect */
            notebook {
                background: rgba(15, 15, 35, 0.8);
                backdrop-filter: blur(10px);
            }
            
            notebook tab {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(10px);
                color: rgba(255, 255, 255, 0.7);
                border-radius: 12px 12px 0 0;
                padding: 14px 28px;
                margin: 0 2px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-bottom: none;
                font-weight: 500;
                font-size: 13px;
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            }
            
            notebook tab:hover {
                background: rgba(255, 255, 255, 0.1);
                color: rgba(255, 255, 255, 0.95);
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            }
            
            notebook tab:checked {
                background: linear-gradient(135deg, rgba(102, 126, 234, 0.9) 0%, rgba(118, 75, 162, 0.9) 100%);
                backdrop-filter: blur(20px);
                color: white;
                border-color: rgba(102, 126, 234, 0.5);
                font-weight: 600;
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5),
                            0 0 30px rgba(102, 126, 234, 0.3);
                transform: translateY(-1px);
            }
            
            /* Sidebar styling (Vivaldi-inspired) */
            .sidebar {
                background: rgba(15, 15, 35, 0.95);
                backdrop-filter: blur(20px);
                border-right: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            /* Scrollbar styling (Opera GX-inspired) */
            scrollbar {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
            }
            
            scrollbar slider {
                background: rgba(102, 126, 234, 0.5);
                border-radius: 10px;
                min-width: 8px;
            }
            
            scrollbar slider:hover {
                background: rgba(102, 126, 234, 0.8);
            }
            
            /* Gaming mode indicator (Opera GX-inspired) */
            .gaming-mode {
                background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
                color: white;
                border-radius: 8px;
                padding: 6px 12px;
                font-weight: 700;
                font-size: 11px;
                text-transform: uppercase;
                letter-spacing: 1px;
                box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            }
            
            /* Resource monitor (Opera GX-inspired) */
            .resource-monitor {
                background: rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
                border-radius: 8px;
                padding: 8px 12px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            /* Privacy badge (Brave-inspired) */
            .privacy-badge {
                background: linear-gradient(135deg, #00ff88 0%, #00d4aa 100%);
                color: #000;
                border-radius: 6px;
                padding: 4px 8px;
                font-weight: 700;
                font-size: 10px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            """
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(css.encode())
        
        screen = Gdk.Screen.get_default()
        style_context = Gtk.StyleContext()
        style_context.add_provider_for_screen(screen, css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
    
    def show_theme_selector(self, button):
        """Show theme selector dialog"""
        dialog = Gtk.Dialog(title="Select Theme", parent=self.window)
        dialog.set_default_size(300, 200)
        
        content = dialog.get_content_area()
        content.set_spacing(10)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        theme_label = Gtk.Label()
        theme_label.set_markup("<b>Choose a theme:</b>")
        content.pack_start(theme_label, False, False, 10)
        
        theme_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        
        default_radio = Gtk.RadioButton(label="Default")
        default_radio.set_active(self.settings.get('theme', 'default') == 'default')
        theme_box.pack_start(default_radio, False, False, 5)
        
        light_radio = Gtk.RadioButton.new_from_widget(default_radio)
        light_radio.set_label("Light")
        light_radio.set_active(self.settings.get('theme', 'default') == 'light')
        theme_box.pack_start(light_radio, False, False, 5)
        
        dark_radio = Gtk.RadioButton.new_from_widget(default_radio)
        dark_radio.set_label("Dark")
        dark_radio.set_active(self.settings.get('theme', 'default') == 'dark')
        theme_box.pack_start(dark_radio, False, False, 5)
        
        content.pack_start(theme_box, False, False, 10)
        
        def apply_theme():
            if default_radio.get_active():
                self.settings['theme'] = 'default'
            elif light_radio.get_active():
                self.settings['theme'] = 'light'
            elif dark_radio.get_active():
                self.settings['theme'] = 'dark'
            
            self.apply_css_styling()
        
        dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)
        apply_btn = dialog.add_button("Apply", Gtk.ResponseType.OK)
        apply_btn.connect("clicked", lambda w: apply_theme())
        
        dialog.show_all()
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            apply_theme()
        dialog.destroy()
    
    def create_ui(self):
        """Create the enhanced browser UI"""
        # Main container
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.window.add(vbox)
        
        # VPN Status Bar - Modern gradient header
        status_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        status_bar.set_margin_start(15)
        status_bar.set_margin_end(15)
        status_bar.set_margin_top(10)
        status_bar.set_margin_bottom(10)
        status_bar.set_name("vpn-status-bar")  # For CSS targeting
        
        self.vpn_status_label = Gtk.Label()
        self.vpn_status_label.set_markup("<b>Checking VPN...</b>")
        status_bar.pack_start(self.vpn_status_label, False, False, 0)
        
        # VPN Connect/Disconnect button
        self.vpn_connect_btn = Gtk.Button(label="üîå Connect VPN")
        self.vpn_connect_btn.connect("clicked", self.on_vpn_connect_clicked)
        status_bar.pack_start(self.vpn_connect_btn, False, False, 5)
        
        # VPN Stats button (shows connection stats)
        self.vpn_stats_btn = Gtk.Button(label="üìä Stats")
        self.vpn_stats_btn.connect("clicked", self.show_vpn_stats)
        status_bar.pack_start(self.vpn_stats_btn, False, False, 5)
        
        # Ghost Mode indicator
        self.ghost_mode_label = Gtk.Label()
        self.ghost_mode_label.set_markup("<b>üëª GHOST MODE</b>")
        self.ghost_mode_label.set_name("ghost-mode")
        status_bar.pack_start(self.ghost_mode_label, False, False, 10)
        
        # Privacy Dashboard button
        self.privacy_dashboard_btn = Gtk.Button(label="üìä Privacy Stats")
        self.privacy_dashboard_btn.connect("clicked", self.show_privacy_dashboard)
        status_bar.pack_start(self.privacy_dashboard_btn, False, False, 5)
        
        # Login button for web portal
        self.login_btn = Gtk.Button(label="üîê Login")
        self.login_btn.connect("clicked", self.show_login_dialog)
        status_bar.pack_start(self.login_btn, False, False, 5)
        
        refresh_btn = Gtk.Button(label="üîÑ Refresh")
        refresh_btn.connect("clicked", lambda w: self.check_vpn_status())
        refresh_btn.connect("clicked", lambda w: self.update_vpn_status())
        status_bar.pack_end(refresh_btn, False, False, 0)
        
        vbox.pack_start(status_bar, False, False, 0)
        
        # Tab bar
        self.tab_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=2)
        self.tab_bar.set_margin_start(5)
        self.tab_bar.set_margin_end(5)
        self.tab_bar.set_margin_bottom(2)
        vbox.pack_start(self.tab_bar, False, False, 0)
        
        # Navigation Bar - Modern toolbar
        nav_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        nav_bar.set_margin_start(12)
        nav_bar.set_margin_end(12)
        nav_bar.set_margin_top(8)
        nav_bar.set_margin_bottom(8)
        nav_bar.set_name("nav-bar")  # For CSS targeting
        
        back_btn = Gtk.Button(label="‚óÄ")
        back_btn.connect("clicked", lambda w: self.go_back())
        nav_bar.pack_start(back_btn, False, False, 0)
        
        forward_btn = Gtk.Button(label="‚ñ∂")
        forward_btn.connect("clicked", lambda w: self.go_forward())
        nav_bar.pack_start(forward_btn, False, False, 0)
        
        refresh_web_btn = Gtk.Button(label="üîÑ")
        refresh_web_btn.connect("clicked", lambda w: self.reload())
        nav_bar.pack_start(refresh_web_btn, False, False, 0)
        
        self.url_entry = Gtk.Entry()
        self.url_entry.set_placeholder_text("Enter URL or search...")
        self.url_entry.connect("activate", self.on_url_activate)
        nav_bar.pack_start(self.url_entry, True, True, 0)
        
        go_btn = Gtk.Button(label="Go")
        go_btn.connect("clicked", self.on_go_clicked)
        nav_bar.pack_start(go_btn, False, False, 0)
        
        # Bookmarks button
        bookmarks_btn = Gtk.Button(label="‚≠ê")
        bookmarks_btn.connect("clicked", self.show_bookmarks)
        nav_bar.pack_start(bookmarks_btn, False, False, 0)
        
        # History button
        history_btn = Gtk.Button(label="üïê")
        history_btn.connect("clicked", self.show_history)
        nav_bar.pack_start(history_btn, False, False, 0)
        
        # New tab button
        new_tab_btn = Gtk.Button(label="‚ûï")
        new_tab_btn.connect("clicked", self.new_tab)
        nav_bar.pack_start(new_tab_btn, False, False, 0)
        
        # Downloads button
        downloads_btn = Gtk.Button(label="‚¨áÔ∏è")
        downloads_btn.connect("clicked", self.show_downloads)
        nav_bar.pack_start(downloads_btn, False, False, 0)
        
        # Theme button
        theme_btn = Gtk.Button(label="üé®")
        theme_btn.connect("clicked", self.show_theme_selector)
        nav_bar.pack_start(theme_btn, False, False, 0)
        
        # Settings button
        settings_btn = Gtk.Button(label="‚öôÔ∏è")
        settings_btn.connect("clicked", self.show_settings)
        nav_bar.pack_start(settings_btn, False, False, 0)
        
        # Opera GX Gaming Mode button
        self.gaming_mode_btn = Gtk.Button(label="üéÆ GX")
        self.gaming_mode_btn.connect("clicked", self.toggle_gaming_mode)
        nav_bar.pack_start(self.gaming_mode_btn, False, False, 0)
        
        # Vivaldi Sidebar toggle
        self.sidebar_toggle_btn = Gtk.Button(label="üìë")
        self.sidebar_toggle_btn.connect("clicked", self.toggle_sidebar)
        nav_bar.pack_start(self.sidebar_toggle_btn, False, False, 0)
        
        # Firefox Container selector
        self.container_btn = Gtk.Button(label="üì¶")
        self.container_btn.connect("clicked", self.show_container_menu)
        nav_bar.pack_start(self.container_btn, False, False, 0)
        
        # Brave Shields button
        self.shields_btn = Gtk.Button(label="üõ°Ô∏è")
        self.shields_btn.connect("clicked", self.show_shields_panel)
        nav_bar.pack_start(self.shields_btn, False, False, 0)
        
        # Safari Reader Mode button
        self.reader_btn = Gtk.Button(label="üìñ")
        self.reader_btn.connect("clicked", self.toggle_reader_mode)
        nav_bar.pack_start(self.reader_btn, False, False, 0)
        
        # Speed Dial button (Opera)
        speed_dial_btn = Gtk.Button(label="üöÄ")
        speed_dial_btn.connect("clicked", self.show_speed_dial)
        nav_bar.pack_start(speed_dial_btn, False, False, 0)
        
        vbox.pack_start(nav_bar, False, False, 0)
        
        # Main content area with sidebar support
        main_hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        
        # Vivaldi Sidebar (initially hidden)
        self.sidebar = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.sidebar.set_size_request(250, -1)
        self.sidebar.set_visible(False)
        main_hbox.pack_start(self.sidebar, False, False, 0)
        
        # Create sidebar content
        self.create_sidebar()
        
        # Notebook for tabs
        self.notebook = Gtk.Notebook()
        self.notebook.set_scrollable(True)
        self.notebook.connect("switch-page", self.on_tab_switched)
        main_hbox.pack_start(self.notebook, True, True, 0)
        
        vbox.pack_start(main_hbox, True, True, 0)
        
        # Opera GX Resource Monitor (bottom bar)
        self.resource_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        self.resource_bar.set_margin_start(10)
        self.resource_bar.set_margin_end(10)
        self.resource_bar.set_margin_top(5)
        self.resource_bar.set_margin_bottom(5)
        self.resource_bar.set_name("resource-bar")
        
        self.cpu_label = Gtk.Label(label="CPU: --%")
        self.ram_label = Gtk.Label(label="RAM: --%")
        self.network_label = Gtk.Label(label="NET: --%")
        
        self.resource_bar.pack_start(self.cpu_label, False, False, 0)
        self.resource_bar.pack_start(self.ram_label, False, False, 0)
        self.resource_bar.pack_start(self.network_label, False, False, 0)
        
        self.resource_bar.set_visible(False)  # Hidden by default, show in gaming mode
        vbox.pack_start(self.resource_bar, False, False, 0)
        
        # Create first tab
        self.new_tab("https://www.google.com" if self.vpn_connected else None)
        
        # Update status
        self.update_vpn_status()
        
        # Start resource monitoring (Opera GX) - only if psutil available
        try:
            import psutil
            self.start_resource_monitoring()
        except ImportError:
            pass  # psutil not available, skip monitoring
    
    def new_tab(self, url="https://phazevpn.com"):
        """Create a new tab"""
        webview = self.create_webview()
        
        scrolled = Gtk.ScrolledWindow()
        scrolled.add(webview)
        
        # Tab label with favicon support
        tab_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        
        # Favicon (placeholder for now)
        favicon_label = Gtk.Label(label="üåê")
        favicon_label.set_size_request(16, 16)
        tab_box.pack_start(favicon_label, False, False, 0)
        
        label = Gtk.Label(label="New Tab")
        label.set_ellipsize(3)  # Ellipsize at end
        label.set_max_width_chars(20)
        tab_box.pack_start(label, True, True, 0)
        
        close_btn = Gtk.Button(label="‚úï")
        close_btn.set_relief(Gtk.ReliefStyle.NONE)
        close_btn.set_size_request(20, 20)
        close_btn.set_tooltip_text("Close tab")
        tab_box.pack_start(close_btn, False, False, 0)
        tab_box.show_all()
        
        page_num = self.notebook.append_page(scrolled, tab_box)
        
        tab_info = {
            'webview': webview,
            'label': label,
            'favicon_label': favicon_label,
            'close_btn': close_btn,
            'page_num': page_num,
            'url': url or "",
            'title': "New Tab"
        }
        
        close_btn.connect("clicked", lambda w: self.close_tab(tab_info))
        
        self.tabs.append(tab_info)
        self.current_tab = tab_info
        self.notebook.set_current_page(page_num)
        
        self.navigate_to_url(url)
        
        if not self.vpn_connected:
            self.show_vpn_warning()
    
    def close_tab(self, tab_info):
        """Close a tab"""
        if len(self.tabs) <= 1:
            # Don't close last tab
            return
        
        page_num = tab_info['page_num']
        self.notebook.remove_page(page_num)
        self.tabs.remove(tab_info)
        
        if tab_info == self.current_tab:
            # Switch to another tab
            if self.tabs:
                self.current_tab = self.tabs[0]
                self.notebook.set_current_page(self.current_tab['page_num'])
    
    def on_tab_switched(self, notebook, page, page_num):
        """Handle tab switch"""
        for tab in self.tabs:
            if tab['page_num'] == page_num:
                self.current_tab = tab
                uri = tab['webview'].get_uri()
                if uri:
                    self.url_entry.set_text(uri)
                break
    
    def go_back(self):
        """Go back in current tab"""
        if self.current_tab:
            self.current_tab['webview'].go_back()
    
    def go_forward(self):
        """Go forward in current tab"""
        if self.current_tab:
            self.current_tab['webview'].go_forward()
    
    def reload(self):
        """Reload current tab"""
        if self.current_tab:
            self.current_tab['webview'].reload()
    
    def on_url_activate(self, entry):
        """Handle URL entry activation"""
        self.navigate_to_url(entry.get_text())
    
    def on_go_clicked(self, button):
        """Handle Go button click"""
        self.navigate_to_url(self.url_entry.get_text())
    
    def navigate_to_url(self, url):
        """Navigate to URL"""
        if not self.vpn_connected:
            self.show_vpn_warning()
            return
        
        if not self.current_tab:
            self.new_tab()
        
        # Add protocol if missing
        if not url.startswith(('http://', 'https://')):
            if '.' in url and ' ' not in url:
                url = 'https://' + url
            else:
                # Search query
                url = f"https://www.google.com/search?q={url.replace(' ', '+')}"
        
        self.current_tab['webview'].load_uri(url)
    
    def on_load_changed(self, webview, load_event):
        """Handle page load events"""
        if load_event == WebKit2.LoadEvent.FINISHED:
            uri = webview.get_uri()
            if uri and self.current_tab and webview == self.current_tab['webview']:
                self.url_entry.set_text(uri)
                self.save_history(uri, webview.get_title() or uri)
    
    def on_title_changed(self, webview, title):
        """Handle title change"""
        # Update all tabs with matching webview
        for tab in self.tabs:
            if tab['webview'] == webview:
                title_text = webview.get_title() or "New Tab"
                tab['title'] = title_text
                # Truncate for display
                display_text = title_text[:25] + "..." if len(title_text) > 25 else title_text
                tab['label'].set_text(display_text)
                # Update tab label in notebook
                if tab == self.current_tab:
                    # Update favicon if available (placeholder for now)
                    pass
                break
    
    def show_bookmarks(self, button):
        """Show bookmarks menu"""
        menu = Gtk.Menu()
        
        if not self.bookmarks:
            item = Gtk.MenuItem(label="No bookmarks yet")
            item.set_sensitive(False)
            menu.append(item)
        else:
            for bookmark in self.bookmarks[:20]:  # Show last 20
                item = Gtk.MenuItem(label=bookmark.get('title', bookmark.get('url', '')))
                item.connect("activate", lambda w, url=bookmark.get('url'): self.navigate_to_url(url))
                menu.append(item)
        
        menu.append(Gtk.SeparatorMenuItem())
        
        # Add current page
        add_item = Gtk.MenuItem(label="Add Current Page")
        if self.current_tab:
            uri = self.current_tab['webview'].get_uri()
            title = self.current_tab['webview'].get_title() or uri
            if uri:
                add_item.connect("activate", lambda w: self.add_bookmark(uri, title))
        else:
            add_item.set_sensitive(False)
        menu.append(add_item)
        
        menu.show_all()
        menu.popup(None, None, None, None, 0, Gtk.get_current_event_time())
    
    def add_bookmark(self, url, title):
        """Add current page to bookmarks"""
        self.bookmarks.insert(0, {'url': url, 'title': title, 'added': datetime.now().isoformat()})
        self.save_bookmarks()
    
    def show_history(self, button):
        """Show history menu"""
        menu = Gtk.Menu()
        
        if not self.history:
            item = Gtk.MenuItem(label="No history yet")
            item.set_sensitive(False)
            menu.append(item)
        else:
            for entry in self.history[:20]:  # Show last 20
                title = entry.get('title', entry.get('url', ''))
                item = Gtk.MenuItem(label=title[:50])
                item.connect("activate", lambda w, url=entry.get('url'): self.navigate_to_url(url))
                menu.append(item)
        
        menu.show_all()
        menu.popup(None, None, None, None, 0, Gtk.get_current_event_time())
    
    def on_vpn_connect_clicked(self, button):
        """Handle VPN connect/disconnect button click"""
        if self.vpn_connected:
            self.disconnect_vpn()
        else:
            self.show_vpn_connect_dialog()
    
    def show_vpn_connect_dialog(self):
        """Show dialog to connect to VPN"""
        dialog = Gtk.Dialog(title="Connect to PhazeVPN", parent=self.window)
        dialog.set_default_size(500, 400)
        
        content = dialog.get_content_area()
        content.set_spacing(10)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        # Instructions
        info_label = Gtk.Label()
        info_label.set_markup("<b>Connect to PhazeVPN</b>\n\nSelect your client and protocol to connect.")
        info_label.set_line_wrap(True)
        content.pack_start(info_label, False, False, 10)
        
        # Client selection
        client_frame = Gtk.Frame(label="Client")
        client_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        client_frame.add(client_box)
        
        self.client_combo = Gtk.ComboBoxText()
        # Try to get clients from Downloads folder or web portal
        self.load_available_clients()
        client_box.pack_start(self.client_combo, False, False, 5)
        
        refresh_clients_btn = Gtk.Button(label="üîÑ Refresh Clients")
        refresh_clients_btn.connect("clicked", lambda w: self.load_available_clients())
        client_box.pack_start(refresh_clients_btn, False, False, 5)
        
        client_box.set_margin_start(10)
        client_box.set_margin_end(10)
        client_box.set_margin_top(10)
        client_box.set_margin_bottom(10)
        content.pack_start(client_frame, False, False, 10)
        
        # Protocol selection
        protocol_frame = Gtk.Frame(label="Protocol")
        protocol_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        protocol_frame.add(protocol_box)
        
        self.protocol_combo = Gtk.ComboBoxText()
        self.protocol_combo.append_text("OpenVPN (Recommended)")
        self.protocol_combo.append_text("WireGuard (Modern)")
        self.protocol_combo.append_text("PhazeVPN (Experimental)")
        self.protocol_combo.set_active(0)
        protocol_box.pack_start(self.protocol_combo, False, False, 5)
        
        protocol_box.set_margin_start(10)
        protocol_box.set_margin_end(10)
        protocol_box.set_margin_top(10)
        protocol_box.set_margin_bottom(10)
        content.pack_start(protocol_frame, False, False, 10)
        
        # Download config option
        download_check = Gtk.CheckButton(label="Download config from server if not found")
        download_check.set_active(True)
        content.pack_start(download_check, False, False, 5)
        
        # Status label
        self.connect_status_label = Gtk.Label()
        self.connect_status_label.set_text("")
        content.pack_start(self.connect_status_label, False, False, 5)
        
        # Buttons
        dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)
        connect_btn = dialog.add_button("üîå Connect", Gtk.ResponseType.OK)
        connect_btn.connect("clicked", lambda w: self.connect_vpn_from_dialog(dialog, download_check))
        
        dialog.show_all()
        response = dialog.run()
        dialog.destroy()
    
    def load_available_clients(self):
        """Load available VPN clients from Downloads folder and web portal"""
        self.client_combo.remove_all()
        
        # Check Downloads folder for config files
        configs_found = []
        for ext in ['.ovpn', '.conf', '.phazevpn']:
            for config_file in self.vpn_configs_dir.glob(f'*{ext}'):
                client_name = config_file.stem.replace('.ovpn', '').replace('.conf', '').replace('.phazevpn', '')
                if client_name not in configs_found:
                    configs_found.append(client_name)
                    self.client_combo.append_text(client_name)
        
        # Try to get clients from web portal API if requests is available
        if REQUESTS_AVAILABLE:
            try:
                vps_url = os.environ.get("PHASEVPN_URL", "https://phazevpn.com")
                api_url = f"{vps_url}/api/app/configs"
                
                # Try to get clients (may need authentication)
                response = requests.get(api_url, timeout=5, verify=False)
                if response.status_code == 200:
                    data = response.json()
                    clients = data.get('configs', [])
                    for client in clients:
                        client_name = client.get('name') or client.get('vpn_config', '')
                        if client_name and client_name not in configs_found:
                            configs_found.append(client_name)
                            self.client_combo.append_text(client_name)
            except:
                pass  # Silently fail if API not available
        
        if not configs_found:
            self.client_combo.append_text("No configs found - will download")
            if hasattr(self, 'connect_status_label'):
                self.connect_status_label.set_text("‚ö†Ô∏è No configs found. Will download from server.")
        else:
            self.client_combo.set_active(0)
    
    def connect_vpn_from_dialog(self, dialog, download_check):
        """Connect to VPN using selected client and protocol"""
        client_name = self.client_combo.get_active_text()
        protocol_text = self.protocol_combo.get_active_text()
        
        if not client_name or client_name == "No configs found - will download":
            self.connect_status_label.set_text("‚ùå Please select a client or download one first")
            return
        
        # Map protocol text to protocol name
        protocol_map = {
            "OpenVPN (Recommended)": "openvpn",
            "WireGuard (Modern)": "wireguard",
            "PhazeVPN (Experimental)": "phazevpn"
        }
        protocol = protocol_map.get(protocol_text, "openvpn")
        
        # Find config file
        config_file = None
        if protocol == "openvpn":
            config_file = self.vpn_configs_dir / f"{client_name}.ovpn"
        elif protocol == "wireguard":
            config_file = self.vpn_configs_dir / f"{client_name}.conf"
        else:  # phazevpn
            config_file = self.vpn_configs_dir / f"{client_name}.phazevpn"
        
        # If config doesn't exist and download is enabled, try to download
        if not config_file.exists() and download_check.get_active():
            self.connect_status_label.set_text("‚è≥ Downloading config from server...")
            dialog.show_all()
            
            # Try to download from web portal
            if not REQUESTS_AVAILABLE:
                self.connect_status_label.set_text("‚ùå requests module not available. Install with: pip3 install requests")
                return
            
            try:
                vps_url = os.environ.get("PHASEVPN_URL", "https://phazevpn.com")
                download_url = f"{vps_url}/download/{client_name}?type={protocol}"
                
                # Disable SSL warnings for self-signed certs
                import urllib3
                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
                
                response = requests.get(download_url, timeout=15, verify=False)
                if response.status_code == 200:
                    config_file.write_bytes(response.content)
                    config_file.chmod(0o600)
                    self.connect_status_label.set_text("‚úÖ Config downloaded!")
                elif response.status_code == 401:
                    self.connect_status_label.set_text("‚ùå Authentication required. Please login at phazevpn.com first.")
                    return
                else:
                    self.connect_status_label.set_text(f"‚ùå Failed to download config: {response.status_code}")
                    return
            except Exception as e:
                self.connect_status_label.set_text(f"‚ùå Download failed: {str(e)[:50]}")
                return
        
        if not config_file.exists():
            self.connect_status_label.set_text(f"‚ùå Config file not found: {config_file}")
            return
        
        # Connect to VPN
        self.connect_status_label.set_text("‚è≥ Connecting...")
        dialog.show_all()
        
        success = self.connect_vpn(config_file, protocol, client_name)
        
        if success:
            self.connect_status_label.set_text("‚úÖ Connected! Closing dialog...")
            GLib.timeout_add(500, lambda: dialog.response(Gtk.ResponseType.OK))
        else:
            self.connect_status_label.set_text("‚ùå Connection failed. Check terminal for details.")
    
    def connect_vpn(self, config_file, protocol, client_name):
        """Connect to VPN using the config file"""
        try:
            if protocol == "openvpn":
                # Find OpenVPN binary
                openvpn_paths = [
                    Path("/usr/sbin/openvpn"),
                    Path("/usr/bin/openvpn"),
                    Path("/usr/local/bin/openvpn"),
                ]
                
                openvpn_binary = None
                for path in openvpn_paths:
                    if path.exists():
                        openvpn_binary = path
                        break
                
                if not openvpn_binary:
                    print("‚ùå OpenVPN not found. Install with: sudo apt install openvpn")
                    return False
                
                # Launch OpenVPN (requires sudo)
                cmd = ['sudo', str(openvpn_binary), '--config', str(config_file), '--daemon']
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                
                if result.returncode == 0:
                    self.vpn_process = "openvpn"
                    self.vpn_protocol = protocol
                    self.vpn_client_name = client_name
                    self.vpn_connection_start_time = time.time()
                    self.vpn_session_bytes_sent = 0
                    self.vpn_session_bytes_received = 0
                    # Extract server IP from config
                    try:
                        with open(config_file, 'r') as f:
                            config_content = f.read()
                            for line in config_content.split('\n'):
                                if line.startswith('remote '):
                                    parts = line.split()
                                    if len(parts) >= 2:
                                        self.vpn_server_ip = parts[1]
                                        break
                    except:
                        pass
                    time.sleep(2)  # Wait for connection
                    self.check_vpn_status()
                    return True
                else:
                    print(f"‚ùå OpenVPN failed: {result.stderr}")
                    return False
                    
            elif protocol == "wireguard":
                # Find wg-quick binary
                wg_quick_paths = [
                    Path("/usr/bin/wg-quick"),
                    Path("/usr/local/bin/wg-quick"),
                ]
                
                wg_quick_binary = None
                for path in wg_quick_paths:
                    if path.exists():
                        wg_quick_binary = path
                        break
                
                if not wg_quick_binary:
                    print("‚ùå WireGuard not found. Install with: sudo apt install wireguard")
                    return False
                
                # Launch WireGuard
                interface_name = config_file.stem.replace(' ', '_').replace('-', '_')
                cmd = ['sudo', str(wg_quick_binary), 'up', str(config_file)]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                
                if result.returncode == 0:
                    self.vpn_process = "wireguard"
                    self.vpn_protocol = protocol
                    self.vpn_client_name = client_name
                    self.vpn_connection_start_time = time.time()
                    self.vpn_session_bytes_sent = 0
                    self.vpn_session_bytes_received = 0
                    # Extract server IP from config
                    try:
                        with open(config_file, 'r') as f:
                            config_content = f.read()
                            for line in config_content.split('\n'):
                                if line.startswith('Endpoint = '):
                                    endpoint = line.split('=')[1].strip()
                                    self.vpn_server_ip = endpoint.split(':')[0]
                                    break
                    except:
                        pass
                    time.sleep(2)
                    self.check_vpn_status()
                    return True
                else:
                    print(f"‚ùå WireGuard failed: {result.stderr}")
                    return False
                    
            else:  # phazevpn
                print("‚ö†Ô∏è PhazeVPN client not yet implemented in browser")
                return False
                
        except Exception as e:
            print(f"‚ùå VPN connection error: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def disconnect_vpn(self):
        """Disconnect from VPN"""
        try:
            if self.vpn_protocol == "openvpn":
                subprocess.run(['sudo', 'pkill', '-f', 'openvpn'], capture_output=True)
            elif self.vpn_protocol == "wireguard":
                if self.vpn_client_name:
                    subprocess.run(['sudo', 'wg-quick', 'down', self.vpn_client_name], capture_output=True)
                subprocess.run(['sudo', 'wg-quick', 'down', 'wg0'], capture_output=True)
            
            self.vpn_process = None
            self.vpn_protocol = None
            self.vpn_client_name = None
            self.vpn_connection_start_time = None
            self.vpn_session_bytes_sent = 0
            self.vpn_session_bytes_received = 0
            self.vpn_latency = None
            self.vpn_server_ip = None
            time.sleep(1)
            self.check_vpn_status()
            self.update_vpn_status()
            
            # Kill switch - block all traffic if enabled
            if self.kill_switch_enabled:
                self.enable_kill_switch()
            
        except Exception as e:
            print(f"‚ùå Disconnect error: {e}")
    
    def show_vpn_stats(self, button):
        """Show VPN connection statistics dialog"""
        dialog = Gtk.Dialog(title="VPN Connection Statistics", parent=self.window)
        dialog.set_default_size(500, 400)
        
        content = dialog.get_content_area()
        content.set_spacing(10)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        if not self.vpn_connected:
            info_label = Gtk.Label()
            info_label.set_text("VPN is not connected. Connect to VPN to view statistics.")
            content.pack_start(info_label, False, False, 10)
        else:
            # Connection info
            info_frame = Gtk.Frame(label="Connection Information")
            info_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
            info_frame.add(info_box)
            
            # Protocol
            protocol_label = Gtk.Label()
            protocol_label.set_markup(f"<b>Protocol:</b> {self.vpn_protocol.upper() if self.vpn_protocol else 'Unknown'}")
            protocol_label.set_halign(Gtk.Align.START)
            info_box.pack_start(protocol_label, False, False, 5)
            
            # Interface
            interface_label = Gtk.Label()
            interface_label.set_markup(f"<b>Interface:</b> {self.vpn_interface or 'Unknown'}")
            interface_label.set_halign(Gtk.Align.START)
            info_box.pack_start(interface_label, False, False, 5)
            
            # Server
            server_label = Gtk.Label()
            server_label.set_markup(f"<b>Server:</b> {self.vpn_server_ip or 'Unknown'}")
            server_label.set_halign(Gtk.Align.START)
            info_box.pack_start(server_label, False, False, 5)
            
            # Client
            client_label = Gtk.Label()
            client_label.set_markup(f"<b>Client:</b> {self.vpn_client_name or 'Unknown'}")
            client_label.set_halign(Gtk.Align.START)
            info_box.pack_start(client_label, False, False, 5)
            
            # Connection time
            if self.vpn_connection_start_time:
                elapsed = time.time() - self.vpn_connection_start_time
                hours = int(elapsed // 3600)
                minutes = int((elapsed % 3600) // 60)
                seconds = int(elapsed % 60)
                time_str = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
            else:
                time_str = "Unknown"
            
            time_label = Gtk.Label()
            time_label.set_markup(f"<b>Connection Time:</b> {time_str}")
            time_label.set_halign(Gtk.Align.START)
            info_box.pack_start(time_label, False, False, 5)
            
            info_box.set_margin_start(10)
            info_box.set_margin_end(10)
            info_box.set_margin_top(10)
            info_box.set_margin_bottom(10)
            content.pack_start(info_frame, False, False, 10)
            
            # Statistics
            stats_frame = Gtk.Frame(label="Statistics")
            stats_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
            stats_frame.add(stats_box)
            
            # Latency
            latency_label = Gtk.Label()
            latency_text = f"{self.vpn_latency}ms" if self.vpn_latency else "Measuring..."
            latency_label.set_markup(f"<b>Latency:</b> {latency_text}")
            latency_label.set_halign(Gtk.Align.START)
            stats_box.pack_start(latency_label, False, False, 5)
            
            # Data transferred
            def format_bytes(bytes_val):
                for unit in ['B', 'KB', 'MB', 'GB']:
                    if bytes_val < 1024.0:
                        return f"{bytes_val:.2f} {unit}"
                    bytes_val /= 1024.0
                return f"{bytes_val:.2f} TB"
            
            sent_label = Gtk.Label()
            sent_label.set_markup(f"<b>Data Sent:</b> {format_bytes(self.vpn_session_bytes_sent)}")
            sent_label.set_halign(Gtk.Align.START)
            stats_box.pack_start(sent_label, False, False, 5)
            
            received_label = Gtk.Label()
            received_label.set_markup(f"<b>Data Received:</b> {format_bytes(self.vpn_session_bytes_received)}")
            received_label.set_halign(Gtk.Align.START)
            stats_box.pack_start(received_label, False, False, 5)
            
            total_label = Gtk.Label()
            total_bytes = self.vpn_session_bytes_sent + self.vpn_session_bytes_received
            total_label.set_markup(f"<b>Total Data:</b> {format_bytes(total_bytes)}")
            total_label.set_halign(Gtk.Align.START)
            stats_box.pack_start(total_label, False, False, 5)
            
            stats_box.set_margin_start(10)
            stats_box.set_margin_end(10)
            stats_box.set_margin_top(10)
            stats_box.set_margin_bottom(10)
            content.pack_start(stats_frame, False, False, 10)
            
            # Refresh button
            refresh_btn = Gtk.Button(label="üîÑ Refresh Stats")
            refresh_btn.connect("clicked", lambda w: self.update_vpn_stats())
            refresh_btn.connect("clicked", lambda w: dialog.destroy())
            refresh_btn.connect("clicked", lambda w: self.show_vpn_stats(button))
            content.pack_start(refresh_btn, False, False, 5)
        
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def show_login_dialog(self, button):
        """Show web portal login dialog"""
        dialog = Gtk.Dialog(title="Login to PhazeVPN Portal", parent=self.window)
        dialog.set_default_size(400, 300)
        
        content = dialog.get_content_area()
        content.set_spacing(10)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        # Instructions
        info_label = Gtk.Label()
        info_label.set_markup("<b>Login to PhazeVPN Portal</b>\n\nLogin to automatically fetch your VPN clients.")
        info_label.set_line_wrap(True)
        content.pack_start(info_label, False, False, 10)
        
        # Username
        username_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        username_label = Gtk.Label(label="Username:")
        username_label.set_size_request(100, -1)
        username_entry = Gtk.Entry()
        username_entry.set_placeholder_text("Enter username")
        username_box.pack_start(username_label, False, False, 0)
        username_box.pack_start(username_entry, True, True, 0)
        content.pack_start(username_box, False, False, 5)
        
        # Password
        password_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        password_label = Gtk.Label(label="Password:")
        password_label.set_size_request(100, -1)
        password_entry = Gtk.Entry()
        password_entry.set_placeholder_text("Enter password")
        password_entry.set_visibility(False)
        password_box.pack_start(password_label, False, False, 0)
        password_box.pack_start(password_entry, True, True, 0)
        content.pack_start(password_box, False, False, 5)
        
        # Portal URL
        url_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        url_label = Gtk.Label(label="Portal URL:")
        url_label.set_size_request(100, -1)
        url_entry = Gtk.Entry()
        url_entry.set_text(os.environ.get("PHASEVPN_URL", "https://phazevpn.com"))
        url_box.pack_start(url_label, False, False, 0)
        url_box.pack_start(url_entry, True, True, 0)
        content.pack_start(url_box, False, False, 5)
        
        # Status label
        status_label = Gtk.Label()
        status_label.set_text("")
        content.pack_start(status_label, False, False, 5)
        
        def do_login():
            username = username_entry.get_text().strip()
            password = password_entry.get_text()
            portal_url = url_entry.get_text().strip()
            
            if not portal_url:
                portal_url = "http://15.204.11.19:5000"  # Default to real VPS
            elif "://" not in portal_url:
                portal_url = "http://" + portal_url
            
            if not username or not password:
                status_label.set_text("‚ùå Please enter username and password")
                return
            
            if not REQUESTS_AVAILABLE:
                status_label.set_text("‚ùå requests module not available. Install with: pip3 install requests")
                return
            
            status_label.set_text("‚è≥ Logging in...")
            dialog.show_all()
            
            try:
                # Create session
                session = requests.Session()
                
                # Disable SSL warnings
                import urllib3
                urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
                
                # Login via API
                login_url = f"{portal_url}/api/app/login"
                response = session.post(login_url, json={
                    'username': username,
                    'password': password
                }, timeout=10, verify=False)
                
                if response.status_code == 200:
                    data = response.json()
                    if data.get('success'):
                        # Store session
                        self.web_portal_session = session
                        
                        # Fetch clients
                        status_label.set_text("‚úÖ Login successful! Fetching clients...")
                        dialog.show_all()
                        
                        configs_url = f"{portal_url}/api/app/configs"
                        configs_response = session.get(configs_url, timeout=10, verify=False)
                        
                        if configs_response.status_code == 200:
                            configs_data = configs_response.json()
                            clients = configs_data.get('configs', [])
                            
                            # Download configs
                            downloaded = 0
                            for client in clients:
                                client_name = client.get('name')
                                if client_name:
                                    # Download each protocol type
                                    for protocol_type in ['openvpn', 'wireguard']:
                                        download_url = f"{portal_url}/download/{client_name}?type={protocol_type}"
                                        try:
                                            dl_response = session.get(download_url, timeout=15, verify=False)
                                            if dl_response.status_code == 200:
                                                if protocol_type == 'openvpn':
                                                    config_file = self.vpn_configs_dir / f"{client_name}.ovpn"
                                                else:
                                                    config_file = self.vpn_configs_dir / f"{client_name}.conf"
                                                config_file.write_bytes(dl_response.content)
                                                config_file.chmod(0o600)
                                                downloaded += 1
                                        except:
                                            pass
                            
                            status_label.set_text(f"‚úÖ Success! Downloaded {downloaded} config(s).")
                            GLib.timeout_add(1000, lambda: dialog.response(Gtk.ResponseType.OK))
                        else:
                            status_label.set_text("‚ö†Ô∏è Login successful but failed to fetch clients.")
                    else:
                        status_label.set_text(f"‚ùå Login failed: {data.get('error', 'Unknown error')}")
                else:
                    status_label.set_text(f"‚ùå Login failed: HTTP {response.status_code}")
            except Exception as e:
                status_label.set_text(f"‚ùå Error: {str(e)[:50]}")
        
        # Buttons
        dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)
        login_btn = dialog.add_button("üîê Login", Gtk.ResponseType.OK)
        login_btn.connect("clicked", lambda w: do_login())
        
        dialog.show_all()
        response = dialog.run()
        dialog.destroy()
        
        # Refresh client list after login
        if self.web_portal_session:
            self.load_available_clients()
    
    def enable_kill_switch(self):
        """Enable kill switch - block all traffic if VPN disconnects"""
        if not self.kill_switch_enabled:
            return
        
        try:
            # Use iptables to block all non-VPN traffic
            # This is a basic implementation - may need sudo
            print("üõ°Ô∏è Kill switch enabled - blocking all non-VPN traffic")
            # Note: Full kill switch requires root and iptables configuration
            # This is a placeholder for the feature
        except Exception as e:
            print(f"‚ö†Ô∏è Kill switch error: {e}")
    
    def show_settings(self, button):
        """Show settings dialog"""
        dialog = Gtk.Dialog(title="PhazeBrowser Settings", parent=self.window)
        dialog.set_default_size(500, 500)
        
        content = dialog.get_content_area()
        
        # Privacy settings
        privacy_frame = Gtk.Frame(label="Privacy & Security")
        privacy_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        privacy_frame.add(privacy_box)
        
        ad_block = Gtk.CheckButton(label="Ad Blocking (Basic)")
        ad_block.set_active(self.settings['ad_blocking'])
        ad_block.set_tooltip_text("Basic ad blocking - works for some sites. Advanced blocking coming soon.")
        ad_block.connect("toggled", lambda w: self.settings.update({'ad_blocking': w.get_active()}))
        privacy_box.pack_start(ad_block, False, False, 5)
        
        tracking = Gtk.CheckButton(label="Tracking Protection (Basic)")
        tracking.set_active(self.settings['tracking_protection'])
        tracking.set_tooltip_text("Basic tracking protection - blocks common trackers. Advanced protection coming soon.")
        tracking.connect("toggled", lambda w: self.settings.update({'tracking_protection': w.get_active()}))
        privacy_box.pack_start(tracking, False, False, 5)
        
        fingerprint = Gtk.CheckButton(label="Fingerprinting Protection (Basic)")
        fingerprint.set_active(self.settings['fingerprint_protection'])
        fingerprint.set_tooltip_text("Basic protection - disables WebAudio/media. More techniques coming soon.")
        fingerprint.connect("toggled", lambda w: self.settings.update({'fingerprint_protection': w.get_active()}))
        privacy_box.pack_start(fingerprint, False, False, 5)
        
        webrtc = Gtk.CheckButton(label="WebRTC Protection (via VPN routing)")
        webrtc.set_active(self.settings['webrtc_leak_protection'])
        webrtc.set_sensitive(False)  # Informational only - controlled by VPN
        webrtc.set_tooltip_text("WebRTC traffic routes through VPN at system level")
        privacy_box.pack_start(webrtc, False, False, 5)
        
        dns = Gtk.CheckButton(label="DNS over HTTPS")
        dns.set_active(self.settings['dns_over_https'])
        dns.set_tooltip_text("Use DNS over HTTPS for secure DNS queries")
        dns.connect("toggled", lambda w: self.settings.update({'dns_over_https': w.get_active()}))
        privacy_box.pack_start(dns, False, False, 5)
        
        # Info label
        info_label = Gtk.Label()
        info_label.set_markup("<small><i>Note: WebRTC and DNS protection rely on VPN/system configuration</i></small>")
        info_label.set_margin_top(10)
        privacy_box.pack_start(info_label, False, False, 5)
        
        privacy_box.set_margin_start(10)
        privacy_box.set_margin_end(10)
        privacy_box.set_margin_top(10)
        privacy_box.set_margin_bottom(10)
        
        content.pack_start(privacy_frame, True, True, 10)
        
        # VPN Settings
        vpn_frame = Gtk.Frame(label="VPN Settings")
        vpn_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vpn_frame.add(vpn_box)
        
        auto_reconnect = Gtk.CheckButton(label="Auto-reconnect VPN")
        auto_reconnect.set_active(self.auto_reconnect_enabled)
        auto_reconnect.connect("toggled", lambda w: setattr(self, 'auto_reconnect_enabled', w.get_active()))
        vpn_box.pack_start(auto_reconnect, False, False, 5)
        
        kill_switch = Gtk.CheckButton(label="Kill Switch (Block traffic if VPN disconnects)")
        kill_switch.set_active(self.kill_switch_enabled)
        kill_switch.set_tooltip_text("Warning: Requires root access and may block all internet if VPN fails")
        kill_switch.connect("toggled", lambda w: setattr(self, 'kill_switch_enabled', w.get_active()))
        vpn_box.pack_start(kill_switch, False, False, 5)
        
        vpn_box.set_margin_start(10)
        vpn_box.set_margin_end(10)
        vpn_box.set_margin_top(10)
        vpn_box.set_margin_bottom(10)
        
        content.pack_start(vpn_frame, True, True, 10)
        
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def load_filter_lists(self):
        """Load uBlock Origin filter lists - COMPLETE SET for maximum blocking"""
        config_dir = Path.home() / ".config" / "phazebrowser"
        config_dir.mkdir(parents=True, exist_ok=True)
        
        # uBlock Origin filter lists (same ones uBlock uses)
        filter_lists = {
            'easylist': {
                'url': 'https://easylist.to/easylist/easylist.txt',
                'file': config_dir / "easylist.txt",
                'rules': []
            },
            'easyprivacy': {
                'url': 'https://easylist.to/easylist/easyprivacy.txt',
                'file': config_dir / "easyprivacy.txt",
                'rules': []
            },
            'ublock_filters': {
                'url': 'https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/filters.txt',
                'file': config_dir / "ublock-filters.txt",
                'rules': []
            },
            'ublock_badware': {
                'url': 'https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/badware.txt',
                'file': config_dir / "ublock-badware.txt",
                'rules': []
            },
            'ublock_privacy': {
                'url': 'https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/privacy.txt',
                'file': config_dir / "ublock-privacy.txt",
                'rules': []
            },
            'ublock_annoyances': {
                'url': 'https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/annoyances.txt',
                'file': config_dir / "ublock-annoyances.txt",
                'rules': []
            },
            'fanboy_annoyance': {
                'url': 'https://easylist.to/easylist/fanboy-annoyance.txt',
                'file': config_dir / "fanboy-annoyance.txt",
                'rules': []
            },
            'fanboy_social': {
                'url': 'https://easylist.to/easylist/fanboy-social.txt',
                'file': config_dir / "fanboy-social.txt",
                'rules': []
            },
            'adguard_base': {
                'url': 'https://raw.githubusercontent.com/AdguardTeam/FiltersRegistry/master/filters/filter_2_Base/filter.txt',
                'file': config_dir / "adguard-base.txt",
                'rules': []
            },
            'adguard_spyware': {
                'url': 'https://raw.githubusercontent.com/AdguardTeam/FiltersRegistry/master/filters/filter_3_Spyware/filter.txt',
                'file': config_dir / "adguard-spyware.txt",
                'rules': []
            },
        }
        
        # Download all filter lists
        for name, config in filter_lists.items():
            file_path = config['file']
            url = config['url']
            
            # Download if not present or older than 1 day (keep fresh)
            should_download = (
                not file_path.exists() or 
                (time.time() - file_path.stat().st_mtime) > 86400
            )
            
            if should_download:
                try:
                    print(f"üì• Downloading {name} filter list...")
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
                        'Accept': 'text/plain, */*',
                    }
                    response = requests.get(url, timeout=30, verify=True, headers=headers)
                    if response.status_code == 200:
                        file_path.write_text(response.text)
                        print(f"‚úÖ {name} downloaded ({len(response.text)} bytes)")
                    else:
                        print(f"‚ö†Ô∏è Failed to download {name}: HTTP {response.status_code}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to download {name}: {e}")
                    # Use cached version if available
                    if not file_path.exists():
                        continue
        
        # Parse all filter lists
        all_rules = []
        for name, config in filter_lists.items():
            file_path = config['file']
            if file_path.exists():
                rules = []
                self.parse_filter_list(file_path, rules)
                config['rules'] = rules
                all_rules.extend(rules)
                print(f"‚úÖ Parsed {name}: {len(rules)} rules")
        
        # Combine into main lists
        self.easylist_rules = filter_lists['easylist']['rules'] + filter_lists['ublock_filters']['rules'] + filter_lists['adguard_base']['rules']
        self.easyprivacy_rules = filter_lists['easyprivacy']['rules'] + filter_lists['ublock_privacy']['rules'] + filter_lists['adguard_spyware']['rules']
        
        # Add annoyances and social
        self.easylist_rules.extend(filter_lists['ublock_annoyances']['rules'])
        self.easylist_rules.extend(filter_lists['fanboy_annoyance']['rules'])
        self.easylist_rules.extend(filter_lists['fanboy_social']['rules'])
        
        # Extract blocked domains
        self.extract_blocked_domains()
        
        self.filter_lists_loaded = True
        total_rules = len(self.easylist_rules) + len(self.easyprivacy_rules)
        print(f"‚úÖ uBlock Origin filter lists loaded: {total_rules:,} total rules")
        print(f"   üìä {len(self.easylist_rules):,} ad blocking rules")
        print(f"   üõ°Ô∏è {len(self.easyprivacy_rules):,} privacy rules")
        print(f"   üåê {len(self.blocked_domains):,} blocked domains")
    
    def parse_filter_list(self, filter_file, rules_list):
        """Parse uBlock Origin filter list - FULL SYNTAX SUPPORT"""
        if not filter_file.exists():
            return
        
        try:
            with open(filter_file, 'r', encoding='utf-8', errors='ignore') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    # Skip comments and empty lines
                    if not line or line.startswith('!') or line.startswith('['):
                        continue
                    
                    # uBlock Origin filter syntax support
                    rule_dict = None
                    
                    # Domain blocking: ||domain.com^
                    if line.startswith('||') and '^' in line:
                        parts = line[2:].split('^')
                        domain = parts[0].split('/')[0]
                        if domain:
                            rule_dict = {
                                'type': 'domain',
                                'pattern': domain,
                                'rule': line,
                                'full_match': line.endswith('^')
                            }
                    
                    # URL pattern: /ads/banner.js$ or /ads/banner.js
                    elif line.startswith('/') and (line.endswith('/') or line.endswith('$')):
                        pattern = line.strip('/$')
                        rule_dict = {
                            'type': 'url',
                            'pattern': pattern,
                            'rule': line,
                            'regex': line.startswith('/') and line.endswith('/')
                        }
                    
                    # CSS selector: domain.com##.ad-container or ##.ad-container
                    elif '##' in line:
                        parts = line.split('##')
                        if len(parts) == 2:
                            domain = parts[0] if parts[0] else '*'
                            selector = parts[1]
                            rule_dict = {
                                'type': 'css',
                                'domain': domain,
                                'selector': selector,
                                'rule': line
                            }
                    
                    # Exception rule: @@domain.com^
                    elif line.startswith('@@'):
                        domain = line[2:].split('^')[0].split('/')[0]
                        if domain:
                            rule_dict = {
                                'type': 'exception',
                                'pattern': domain,
                                'rule': line
                            }
                    
                    # Host file format: 0.0.0.0 domain.com
                    elif line.startswith('0.0.0.0') or line.startswith('127.0.0.1'):
                        parts = line.split()
                        if len(parts) >= 2:
                            domain = parts[1].strip()
                            rule_dict = {
                                'type': 'domain',
                                'pattern': domain,
                                'rule': line
                            }
                    
                    # Simple domain: domain.com^
                    elif '^' in line and not line.startswith('||'):
                        domain = line.split('^')[0].replace('|', '').split('/')[0]
                        if domain and '.' in domain:
                            rule_dict = {
                                'type': 'domain',
                                'pattern': domain,
                                'rule': line
                            }
                    
                    # URL contains pattern: ||domain.com/path^
                    elif '||' in line and '^' in line:
                        domain_part = line.split('||')[1].split('^')[0]
                        domain = domain_part.split('/')[0]
                        if domain:
                            rule_dict = {
                                'type': 'domain',
                                'pattern': domain,
                                'rule': line,
                                'path': '/' + '/'.join(domain_part.split('/')[1:]) if '/' in domain_part else None
                            }
                    
                    if rule_dict:
                        rules_list.append(rule_dict)
                        
        except Exception as e:
            print(f"‚ö†Ô∏è Error parsing filter list {filter_file} at line {line_num}: {e}")
    
    def extract_blocked_domains(self):
        """Extract all blocked domains from filter lists"""
        for rule in self.easylist_rules + self.easyprivacy_rules:
            if rule['type'] == 'domain' and 'pattern' in rule:
                self.blocked_domains.add(rule['pattern'].lower())
    
    def load_ad_block_css(self):
        """Load comprehensive ad blocking CSS with extensive filter list support"""
        # Try to load from filter list file
        filter_list_file = Path.home() / ".config" / "phazebrowser" / "adblock-filters.css"
        
        if filter_list_file.exists():
            try:
                return filter_list_file.read_text()
            except:
                pass
        
        # Comprehensive ad blocking CSS - blocks ALL known ad patterns
        return r"""
        /* Comprehensive Ad Blocking - Blocks ALL ad types */
        
        /* Standard ad containers */
        [class*="ad"], [id*="ad"], [class*="advertisement"], 
        [id*="advertisement"], [class*="banner"], iframe[src*="ads"],
        div[class*="sponsored"], [data-ad], .ad-container,
        .adsbygoogle, #google_ads, .ad-banner, 
        [class*="google-ad"], [id*="google-ad"],
        .advertisement, .ad-banner, .ad-wrapper,
        .ad-slot, .ad-unit, .ad-wrapper, .ad-content,
        [class*="doubleclick"], [id*="doubleclick"],
        .popup, .overlay-ad, .sidebar-ad, .header-ad,
        .footer-ad, .inline-ad, .text-ad,
        
        /* Social media ads */
        [class*="fb-ad"], [id*="fb-ad"], [class*="facebook-ad"],
        [class*="twitter-ad"], [class*="instagram-ad"],
        
        /* Video ads */
        [class*="video-ad"], [id*="video-ad"], .pre-roll-ad,
        .mid-roll-ad, .post-roll-ad, .video-ad-container,
        
        /* Native ads */
        [class*="native-ad"], [class*="sponsored-content"],
        [class*="promoted"], [class*="recommended-ad"],
        
        /* Pop-ups and overlays */
        .popup, .modal-ad, .overlay-ad, .lightbox-ad,
        [class*="popup-ad"], [id*="popup-ad"],
        
        /* Sticky ads */
        .sticky-ad, .fixed-ad, [class*="sticky-ad"],
        
        /* Interstitial ads */
        .interstitial-ad, [class*="interstitial"],
        
        /* All ad-related attributes */
        [data-ad], [data-ad-client], [data-ad-slot],
        [data-ad-format], [data-adsbygoogle],
        
        /* Ad networks */
        [class*="adsense"], [id*="adsense"],
        [class*="adwords"], [class*="adform"],
        [class*="criteo"], [class*="outbrain"],
        [class*="taboola"], [class*="revcontent"],
        
        /* Generic ad patterns */
        [class*="promo"], [class*="sponsor"],
        [id*="promo"], [id*="sponsor"],
        
        /* Ad iframes */
        iframe[src*="ads"], iframe[src*="advertising"],
        iframe[src*="doubleclick"], iframe[src*="googlesyndication"],
        iframe[src*="adform"], iframe[src*="adnxs"],
        
        /* Ad images */
        img[src*="ads"], img[src*="advertising"],
        img[src*="doubleclick"], img[src*="adform"],
        
        /* Ad scripts */
        script[src*="ads"], script[src*="advertising"],
        script[src*="doubleclick"], script[src*="googlesyndication"] { 
            display: none !important; 
            visibility: hidden !important;
            height: 0 !important;
            width: 0 !important;
            opacity: 0 !important;
            position: absolute !important;
            display: none !important;
            
            pointer-events: none !important;
            
        }
        
        /* Block ad containers even if they try to show */
        [class*="ad"]:before, [class*="ad"]:after,
        [id*="ad"]:before, [id*="ad"]:after {
            display: none !important;
            content: none !important;
        }
        """
    
    def load_comprehensive_ad_block_js(self):
        """UNDETECTABLE ad blocking - sites can't tell we're blocking"""
        # Generate CSS selectors from filter lists
        css_selectors = []
        for rule in self.easylist_rules:
            if rule.get('type') == 'css':
                selector = rule.get('selector', '')
                if selector:
                    css_selectors.append(selector)
        
        css_rules_str = ', '.join(css_selectors[:100]) if css_selectors else ''  # Limit to first 100
        
        return """
        (function() {{
            'use strict';
            
            // STEALTH MODE - Make blocking undetectable
            // Sites can't detect we're blocking by checking for uBlock/adblock
            
            // Hide adblock detection variables
            const originalDefineProperty = Object.defineProperty;
            Object.defineProperty = function(obj, prop, descriptor) {{
                // Block sites from detecting adblock
                if (prop === 'getBattery' || prop === 'plugins' || prop === 'mimeTypes') {{
                    return obj;
                }}
                return originalDefineProperty.apply(this, arguments);
            }};
            
            // Spoof adblock detection
            window.getComputedStyle = new Proxy(window.getComputedStyle, {{
                apply: function(target, thisArg, args) {{
                    const result = target.apply(thisArg, args);
                    // Make blocked elements appear as if they don't exist
                    return result;
                }}
            }});
            
            // Block adblock detection scripts
            const blockedDetectionPatterns = [
                /adblock/i, /ad.?block/i, /ublock/i, /ad.?blocker/i,
                /block.?ad/i, /detect.?adblock/i, /check.?adblock/i
            ];
            
            // Block detection scripts from loading
            const originalCreateElement = document.createElement;
            document.createElement = function(tagName) {{
                const element = originalCreateElement.call(this, tagName);
                if (tagName === 'script') {{
                    const originalSetAttribute = element.setAttribute;
                    element.setAttribute = function(name, value) {{
                        if (name === 'src' && blockedDetectionPatterns.some(p => p.test(value))) {{
                            return; // Block detection script
                        }}
                        return originalSetAttribute.apply(this, arguments);
                    }};
                }}
                return element;
            }};
            
            // Comprehensive ad blocking patterns (from filter lists)
            const adPatterns = [
                /ads?[_-]?/i, /advertisement/i, /banner/i, /sponsor/i,
                /promo/i, /doubleclick/i, /googlesyndication/i,
                /adsense/i, /adform/i, /adnxs/i, /criteo/i,
                /outbrain/i, /taboola/i, /revcontent/i,
                /facebook.*ad/i, /twitter.*ad/i, /instagram.*ad/i,
                /google.*ad/i, /amazon.*ad/i, /microsoft.*ad/i
            ];
            
            function isAdElement(element) {{
                if (!element) return false;
                
                const className = element.className || '';
                const id = element.id || '';
                const src = element.src || '';
                const href = element.href || '';
                const dataAttr = Array.from(element.attributes || [])
                    .map(attr => attr.name + '=' + attr.value)
                    .join(' ');
                
                const text = (className + ' ' + id + ' ' + src + ' ' + href + ' ' + dataAttr).toLowerCase();
                
                return adPatterns.some(pattern => pattern.test(text));
            }}
            
            // Apply CSS filters from uBlock lists
            """ + (f"""
            const cssRules = {repr(css_rules_str)};
            if (cssRules) {{
                const style = document.createElement('style');
                style.textContent = cssRules + ' {{ display: none !important; visibility: hidden !important; height: 0 !important; width: 0 !important; opacity: 0 !important; }}';
                (document.head || document.documentElement).appendChild(style);
            }}
            """ if css_rules_str else "") + """
            
            function removeAds() {
                // Remove all ad elements silently
                const allElements = document.querySelectorAll('*');
                allElements.forEach(element => {
                    if (isAdElement(element)) {
                        element.style.display = 'none';
                        element.style.visibility = 'hidden';
                        element.style.height = '0';
                        element.style.width = '0';
                        element.style.opacity = '0';
                        element.remove();
                    }
                });
                
                // Remove ad iframes
                const iframes = document.querySelectorAll('iframe');
                iframes.forEach(iframe => {
                    const src = iframe.src || '';
                    if (adPatterns.some(pattern => pattern.test(src))) {
                        iframe.remove();
                    }
                });
            }
            
            // Run immediately (before page renders)
            removeAds();
            
            // Run after DOM loads
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', removeAds);
            } else {
                removeAds();
            }
            
            // Monitor for dynamically added ads (stealth mode)
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === 1) {
                            if (isAdElement(node)) {
                                node.remove();
                            } else {
                                const children = node.querySelectorAll ? node.querySelectorAll('*') : [];
                                children.forEach(child => {
                                    if (isAdElement(child)) {
                                        child.remove();
                                    }
                                });
                            }
                        }
                    });
                });
            });
            
            observer.observe(document.body || document.documentElement, {
                childList: true,
                subtree: true
            });
            
            // Block ad network requests (undetectable)
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                const url = args[0];
                if (typeof url === 'string' && adPatterns.some(pattern => pattern.test(url))) {
                    // Return empty response instead of error (undetectable)
                    return Promise.resolve(new Response('', { status: 200, statusText: 'OK' }));
                }
                return originalFetch.apply(this, args);
            };
            
            // Block XMLHttpRequest to ad domains (undetectable)
            const originalOpen = XMLHttpRequest.prototype.open;
            XMLHttpRequest.prototype.open = function(method, url, ...rest) {
                if (adPatterns.some(pattern => pattern.test(url))) {
                    // Don't throw error - just don't send request
                    this._blocked = true;
                    return;
                }
                return originalOpen.apply(this, [method, url, ...rest]);
            };
            
            const originalSend = XMLHttpRequest.prototype.send;
            XMLHttpRequest.prototype.send = function(...args) {
                if (this._blocked) {
                    return; // Silently block
                }
                return originalSend.apply(this, args);
            };
            
            // Block sendBeacon (tracking)
            if (navigator.sendBeacon) {
                const originalSendBeacon = navigator.sendBeacon;
                navigator.sendBeacon = function(url, data) {
                    if (adPatterns.some(pattern => pattern.test(url))) {
                        return false; // Block silently
                    }
                    return originalSendBeacon.apply(this, arguments);
                };
            }
        })();
        """
    
    def load_comprehensive_tracking_block_js(self):
        """Load comprehensive tracking protection JavaScript"""
        # Comprehensive tracking domain list
        tracking_domains = [
            # Google tracking
            'google-analytics.com', 'googletagmanager.com', 'googleadservices.com',
            'googlesyndication.com', 'doubleclick.net', 'adservice.google',
            'analytics.google', 'google-analytics', 'googletagmanager',
            
            # Facebook tracking
            'facebook.net', 'facebook.com/tr', 'fbcdn.net',
            'connect.facebook.net', 'facebook.com/connect',
            
            # Twitter tracking
            'twitter.com/i/adsct', 'ads-twitter.com',
            
            # Amazon tracking
            'amazon-adsystem.com', 'aax-us-east.amazon-adsystem.com',
            
            # Microsoft tracking
            'bing.com/maps', 'c.microsoft.com',
            
            # Analytics services
            'scorecardresearch.com', 'quantserve.com', 'chartbeat.com',
            'mixpanel.com', 'segment.com', 'amplitude.com',
            'hotjar.com', 'fullstory.com', 'mouseflow.com',
            'crazyegg.com', 'optimizely.com', 'vwo.com',
            
            # Ad networks
            'adnxs.com', 'adsrvr.org', 'adtechus.com',
            'criteo.com', 'rubiconproject.com', 'pubmatic.com',
            'openx.net', 'indexexchange.com', '33across.com',
            'adform.com', 'outbrain.com', 'taboola.com',
            'revcontent.com', 'zemanta.com', 'content.ad',
            
            # Other trackers
            'addthis.com', 'sharethis.com', 'addtoany.com',
            'disqus.com', 'gravatar.com',
            
            # Data brokers
            'bluekai.com', 'lotame.com', 'neustar.biz',
            'exelate.com', 'turn.com',
            
            # Social tracking
            'pinterest.com', 'linkedin.com/px', 'reddit.com/api',
            
            # CDN tracking
            'cloudflare.com/insights', 'jsdelivr.net/stats',
        ]
        
        blocked_js = "const blockedTrackingDomains = " + json.dumps(tracking_domains) + ";"
        blocked_js += """
        (function() {
            'use strict';
            
            function isTrackingDomain(url) {
                if (!url) return false;
                const urlLower = url.toLowerCase();
                return blockedTrackingDomains.some(domain => urlLower.includes(domain));
            }
            
            // Block tracking scripts
            function blockTrackingScripts() {
                const scripts = document.getElementsByTagName('script');
                for (let script of scripts) {
                    if (script.src && isTrackingDomain(script.src)) {
                        script.remove();
                    }
                }
            }
            
            // Block tracking images/pixels
            function blockTrackingImages() {
                const imgs = document.getElementsByTagName('img');
                for (let img of imgs) {
                    if (img.src && isTrackingDomain(img.src)) {
                        img.remove();
                    }
                }
            }
            
            // Block tracking iframes
            function blockTrackingIframes() {
                const iframes = document.getElementsByTagName('iframe');
                for (let iframe of iframes) {
                    if (iframe.src && isTrackingDomain(iframe.src)) {
                        iframe.remove();
                    }
                }
            }
            
            // Block tracking links
            function blockTrackingLinks() {
                const links = document.getElementsByTagName('a');
                for (let link of links) {
                    if (link.href && isTrackingDomain(link.href)) {
                        link.removeAttribute('href');
                    }
                }
            }
            
            // Run blocking functions
            blockTrackingScripts();
            blockTrackingImages();
            blockTrackingIframes();
            blockTrackingLinks();
            
            // Monitor for dynamically added tracking elements
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === 1) { // Element node
                            if (node.tagName === 'SCRIPT' && node.src && isTrackingDomain(node.src)) {
                                node.remove();
                            }
                            if (node.tagName === 'IMG' && node.src && isTrackingDomain(node.src)) {
                                node.remove();
                            }
                            if (node.tagName === 'IFRAME' && node.src && isTrackingDomain(node.src)) {
                                node.remove();
                            }
                        }
                    });
                });
            });
            
            observer.observe(document.body || document.documentElement, {
                childList: true,
                subtree: true
            });
            
            // Block fetch requests to tracking domains
            const originalFetch = window.fetch;
            window.fetch = function(...args) {
                const url = args[0];
                if (typeof url === 'string' && isTrackingDomain(url)) {
                    return Promise.reject(new Error('Tracking request blocked'));
                }
                return originalFetch.apply(this, args);
            };
            
            // Block XMLHttpRequest to tracking domains
            const originalOpen = XMLHttpRequest.prototype.open;
            XMLHttpRequest.prototype.open = function(method, url, ...rest) {
                if (isTrackingDomain(url)) {
                    throw new Error('Tracking request blocked');
                }
                return originalOpen.apply(this, [method, url, ...rest]);
            };
            
            // Block sendBeacon API (used for tracking)
            if (navigator.sendBeacon) {
                const originalSendBeacon = navigator.sendBeacon;
                navigator.sendBeacon = function(url, data) {
                    if (isTrackingDomain(url)) {
                        return false; // Block the beacon
                    }
                    return originalSendBeacon.apply(this, arguments);
                };
            }
        })();
        """
        return blocked_js
    
    def load_cookie_blocking_js(self):
        """COMPLETE GHOST MODE - Block ALL cookies, localStorage, sessionStorage"""
        # COMPLETE LIST of tracking domains
        tracking_domains = [
            'google-analytics.com', 'googletagmanager.com', 'doubleclick.net',
            'googleadservices.com', 'googlesyndication.com', 'facebook.net',
            'facebook.com', 'scorecardresearch.com', 'quantserve.com',
            'adnxs.com', 'criteo.com', 'rubiconproject.com', 'pubmatic.com',
            'openx.net', 'indexexchange.com', 'adform.com', 'outbrain.com',
            'taboola.com', 'revcontent.com', 'mixpanel.com', 'segment.com',
            'amplitude.com', 'hotjar.com', 'fullstory.com', 'mouseflow.com',
            'crazyegg.com', 'optimizely.com', 'vwo.com', 'newrelic.com',
            'addthis.com', 'sharethis.com', 'addtoany.com', 'bluekai.com',
            'lotame.com', 'neustar.biz', 'exelate.com', 'turn.com',
            'amazon-adsystem.com', 'advertising.com', 'adserver.com',
        ]
        
        blocked_js = "const trackingDomains = " + json.dumps(tracking_domains) + ";"
        blocked_js += """
        (function() {
            'use strict';
            
            // COMPLETE GHOST MODE - Block ALL cookies if enabled
            const BLOCK_ALL_COOKIES = """ + str(self.settings.get('block_all_cookies', True)).lower() + """;
            
            function isTrackingDomain(domain) {
                if (!domain) return false;
                const domainLower = domain.toLowerCase();
                return trackingDomains.some(td => domainLower.includes(td));
            }
            
            // COMPLETE COOKIE BLOCKING - Block ALL cookies or just tracking
            const originalCookieDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, 'cookie') ||
                                            Object.getOwnPropertyDescriptor(HTMLDocument.prototype, 'cookie');
            
            if (originalCookieDescriptor && originalCookieDescriptor.set) {
                Object.defineProperty(document, 'cookie', {
                    get: function() {
                        if (BLOCK_ALL_COOKIES) {
                            return ''; // Return empty - no cookies allowed
                        }
                        // Filter out tracking cookies
                        const cookies = originalCookieDescriptor.get.call(this).split(';');
                        const filtered = cookies.filter(cookie => {
                            const name = cookie.split('=')[0].trim();
                            return !isTrackingDomain(name);
                        });
                        return filtered.join(';');
                    },
                    set: function(value) {
                        if (BLOCK_ALL_COOKIES) {
                            // Block ALL cookie setting
                            return false;
                        }
                        // Block only tracking cookies
                        const cookieName = value.split('=')[0].trim();
                        const currentDomain = window.location.hostname;
                        if (isTrackingDomain(currentDomain) || isTrackingDomain(cookieName)) {
                            return false; // Block cookie setting
                        }
                        return originalCookieDescriptor.set.call(this, value);
                    },
                    configurable: true
                });
            }
            
            // COMPLETE STORAGE BLOCKING
            const originalSetItem = Storage.prototype.setItem;
            Storage.prototype.setItem = function(key, value) {
                if (BLOCK_ALL_COOKIES) {
                    // Block ALL localStorage
                    return false;
                }
                const currentDomain = window.location.hostname;
                if (isTrackingDomain(currentDomain)) {
                    return false; // Block localStorage
                }
                return originalSetItem.apply(this, arguments);
            };
            
            const originalSessionSetItem = sessionStorage.setItem;
            sessionStorage.setItem = function(key, value) {
                if (BLOCK_ALL_COOKIES) {
                    // Block ALL sessionStorage
                    return false;
                }
                const currentDomain = window.location.hostname;
                if (isTrackingDomain(currentDomain)) {
                    return false; // Block sessionStorage
                }
                return originalSessionSetItem.apply(this, arguments);
            };
            
            // CLEAR ALL EXISTING COOKIES AND STORAGE
            function clearAllTracking() {
                if (BLOCK_ALL_COOKIES) {
                    // Clear ALL cookies
                    document.cookie.split(';').forEach(cookie => {
                        const name = cookie.split('=')[0].trim();
                        document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                        document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=' + window.location.hostname;
                        // Try all possible domains
                        const parts = window.location.hostname.split('.');
                        for (let i = 0; i < parts.length; i++) {
                            const domain = '.' + parts.slice(i).join('.');
                            document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; domain=' + domain;
                        }
                    });
                    // Clear ALL storage
                    localStorage.clear();
                    sessionStorage.clear();
                } else {
                    // Clear only tracking cookies/storage
                    document.cookie.split(';').forEach(cookie => {
                        const name = cookie.split('=')[0].trim();
                        if (isTrackingDomain(name)) {
                            document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                        }
                    });
                    const currentDomain = window.location.hostname;
                    if (isTrackingDomain(currentDomain)) {
                        localStorage.clear();
                        sessionStorage.clear();
                    }
                }
            }
            
            // Clear immediately
            clearAllTracking();
            
            // Clear periodically (every 5 seconds)
            setInterval(clearAllTracking, 5000);
            
            // Clear on page unload
            window.addEventListener('beforeunload', clearAllTracking);
        })();
        """
        return blocked_js
    
    def load_fingerprint_protection_js(self):
        """Load comprehensive fingerprinting protection"""
        return """
        (function() {
            'use strict';
            
            // Canvas fingerprinting protection
            const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
            const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;
            
            HTMLCanvasElement.prototype.toDataURL = function() {
                // Add noise to canvas to prevent fingerprinting
                const context = this.getContext('2d');
                if (context) {
                    const imageData = context.getImageData(0, 0, this.width, this.height);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        imageData.data[i] += Math.random() * 0.01; // Add tiny noise
                    }
                    context.putImageData(imageData, 0, 0);
                }
                return originalToDataURL.apply(this, arguments);
            };
            
            CanvasRenderingContext2D.prototype.getImageData = function() {
                const imageData = originalGetImageData.apply(this, arguments);
                // Add noise to prevent fingerprinting
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] += Math.random() * 0.01;
                }
                return imageData;
            };
            
            // WebGL fingerprinting protection
            const getParameter = WebGLRenderingContext.prototype.getParameter;
            WebGLRenderingContext.prototype.getParameter = function(parameter) {
                if (parameter === 37445) { // UNMASKED_VENDOR_WEBGL
                    return 'Intel Inc.';
                }
                if (parameter === 37446) { // UNMASKED_RENDERER_WEBGL
                    return 'Intel Iris OpenGL Engine';
                }
                return getParameter.apply(this, arguments);
            };
            
            // Audio fingerprinting protection
            if (window.AudioContext || window.webkitAudioContext) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const originalCreateOscillator = AudioContext.prototype.createOscillator;
                AudioContext.prototype.createOscillator = function() {
                    const oscillator = originalCreateOscillator.apply(this, arguments);
                    const originalFrequency = oscillator.frequency.value;
                    oscillator.frequency.value = originalFrequency + (Math.random() * 0.0001 - 0.00005);
                    return oscillator;
                };
            }
            
            // Font fingerprinting protection
            const originalOffsetWidth = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetWidth');
            const originalOffsetHeight = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight');
            
            if (originalOffsetWidth && originalOffsetWidth.get) {
                Object.defineProperty(HTMLElement.prototype, 'offsetWidth', {
                    get: function() {
                        const width = originalOffsetWidth.get.call(this);
                        return width + (Math.random() * 0.1 - 0.05); // Add tiny noise
                    },
                    configurable: true
                });
            }
            
            // Screen fingerprinting protection
            Object.defineProperty(window.screen, 'width', {
                get: function() { return 1920; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'height', {
                get: function() { return 1080; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'availWidth', {
                get: function() { return 1920; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'availHeight', {
                get: function() { return 1040; },
                configurable: true
            });
            
            // Timezone fingerprinting protection
            const originalGetTimezoneOffset = Date.prototype.getTimezoneOffset;
            Date.prototype.getTimezoneOffset = function() {
                return 0; // Return UTC offset
            };
            
            // Navigator fingerprinting protection
            Object.defineProperty(navigator, 'platform', {
                get: function() { return 'Linux x86_64'; },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'hardwareConcurrency', {
                get: function() { return 4; },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'deviceMemory', {
                get: function() { return 8; },
                configurable: true
            });
            
            // WebRTC leak protection (block RTCPeerConnection)
            if (window.RTCPeerConnection) {
                window.RTCPeerConnection = function() {
                    throw new Error('WebRTC blocked for privacy');
                };
            }
            if (window.webkitRTCPeerConnection) {
                window.webkitRTCPeerConnection = function() {
                    throw new Error('WebRTC blocked for privacy');
                };
            }
            if (window.mozRTCPeerConnection) {
                window.mozRTCPeerConnection = function() {
                    throw new Error('WebRTC blocked for privacy');
                };
            }
            
            // Battery API protection
            if (navigator.getBattery) {
                navigator.getBattery = function() {
                    return Promise.resolve({
                        charging: true,
                        chargingTime: 0,
                        dischargingTime: Infinity,
                        level: 1
                    });
                };
            }
            
            // Permissions API protection
            if (navigator.permissions) {
                const originalQuery = navigator.permissions.query;
                navigator.permissions.query = function(descriptor) {
                    if (descriptor.name === 'notifications' || 
                        descriptor.name === 'geolocation' ||
                        descriptor.name === 'camera' ||
                        descriptor.name === 'microphone') {
                        return Promise.resolve({ state: 'denied' });
                    }
                    return originalQuery.apply(this, arguments);
                };
            }
        })();
        """
    
    def on_decide_policy(self, webview, decision, decision_type, request):
        """COMPLETE GHOST MODE - Block ALL ads, tracking, cookies, everything"""
        # Only handle navigation requests
        if decision_type != WebKit2.PolicyDecisionType.NAVIGATION_ACTION:
            return
        
        try:
            uri = request.get_uri()
            if not uri:
                return
            
            uri_lower = uri.lower()
            from urllib.parse import urlparse
            parsed = urlparse(uri)
            domain = parsed.netloc.lower().lstrip('www.')
            
            # COMPLETE GHOST MODE - Block everything suspicious
            blocked = False
            block_reason = None
            
            # Check against filter lists if loaded
            if self.filter_lists_loaded:
                # Check domain blocking
                for blocked_domain in self.blocked_domains:
                    if blocked_domain in domain or domain.endswith('.' + blocked_domain):
                        blocked = True
                        block_reason = f"Blocked domain: {blocked_domain}"
                        break
                
                if not blocked:
                    # Check URL patterns
                    for rule in self.easylist_rules + self.easyprivacy_rules:
                        if rule['type'] == 'url' and rule['pattern'] in uri_lower:
                            blocked = True
                            block_reason = "Matched filter list rule"
                            break
            
            # COMPREHENSIVE BLOCKING - Block ALL known ad/tracking domains
            if not blocked:
                blocked_patterns = [
                    # Ad networks (COMPLETE LIST)
                    'doubleclick', 'googlesyndication', 'googleadservices', 'adsense',
                    'adform', 'adnxs', 'adsrvr', 'adtech', 'criteo', 'rubiconproject',
                    'pubmatic', 'openx', 'indexexchange', '33across', 'outbrain',
                    'taboola', 'revcontent', 'zemanta', 'content.ad', 'adsystem',
                    'advertising', 'adserver', 'adnetwork', 'adtech', 'advertising.com',
                    'adblade', 'adcolony', 'adroll', 'adsafeprotected', 'adsrv',
                    'adtechus', 'advertising', 'advertising.net', 'adzerk', 'amazon-adsystem',
                    
                    # Tracking (COMPLETE LIST)
                    'google-analytics', 'googletagmanager', 'analytics', 'facebook.net',
                    'facebook.com/tr', 'scorecardresearch', 'quantserve', 'chartbeat',
                    'mixpanel', 'segment', 'amplitude', 'hotjar', 'fullstory', 'mouseflow',
                    'crazyegg', 'optimizely', 'vwo', 'newrelic', 'adobe', 'omniture',
                    'sitecatalyst', 'webtrends', 'coremetrics', 'unica', 'tealium',
                    'ensighten', 'tagman', 'qubit', 'tagcommander', 'signal',
                    
                    # Social tracking
                    'addthis', 'sharethis', 'addtoany', 'sharethrough', 'shareaholic',
                    'gigya', 'janrain', 'loginradius', 'auth0',
                    
                    # Data brokers
                    'bluekai', 'lotame', 'neustar', 'exelate', 'turn', 'liveintent',
                    'thetradedesk', 'appnexus', 'oracle', 'salesforce', 'marketo',
                    'eloqua', 'pardot', 'hubspot', 'act-on', 'marketingcloud',
                    
                    # Cookie/tracking patterns
                    '/tracking/', '/track/', '/pixel', '/beacon', '/collect',
                    '/log', '/logger', '/analytics', '/stats', '/metrics',
                    '/measure', '/monitor', '/telemetry', '/tracker',
                    
                    # Ad patterns in URL
                    '/ads/', '/advertising/', '/banner', '/sponsor', '/promo',
                    '/ad.', '.ad.', '/ad?', '?ad=', '/ad/', '/ads?',
                    'advertisement', 'advert', 'sponsored', 'promotion',
                ]
                
                # Check if URI matches blocked patterns
                for pattern in blocked_patterns:
                    if pattern in uri_lower:
                        blocked = True
                        block_reason = f"Matched pattern: {pattern}"
                        break
            
            if blocked:
                decision.ignore()
                # Track what we blocked
                self.privacy_stats['requests_blocked'] += 1
                self.privacy_stats['domains_blocked'].add(domain)
                GLib.idle_add(self.update_privacy_stats_display)
                return
        except Exception as e:
            pass  # Silently fail if blocking fails
    
    def on_resource_load_started(self, webview, resource, request):
        """COMPLETE GHOST MODE - Block ALL resource loading for ads/trackers"""
        try:
            uri = request.get_uri()
            if not uri:
                return
            
            uri_lower = uri.lower()
            from urllib.parse import urlparse
            parsed = urlparse(uri)
            domain = parsed.netloc.lower().lstrip('www.')
            
            blocked = False
            
            # Check against filter lists if loaded
            if self.filter_lists_loaded:
                # Check if domain is blocked
                for blocked_domain in self.blocked_domains:
                    if blocked_domain in domain or domain.endswith('.' + blocked_domain):
                        blocked = True
                        break
                
                if not blocked:
                    # Check URL patterns
                    for rule in self.easylist_rules + self.easyprivacy_rules:
                        if rule['type'] == 'url' and rule['pattern'] in uri_lower:
                            blocked = True
                            break
            
            # COMPREHENSIVE BLOCKING - Same patterns as navigation
            if not blocked:
                blocked_patterns = [
                    'doubleclick', 'googlesyndication', 'googleadservices', 'adsense',
                    'adform', 'adnxs', 'adsrvr', 'adtech', 'criteo', 'rubiconproject',
                    'google-analytics', 'googletagmanager', 'analytics', 'facebook.net',
                    'facebook.com/tr', 'scorecardresearch', 'quantserve', 'chartbeat',
                    'mixpanel', 'segment', 'amplitude', 'hotjar', 'fullstory',
                    '/ads/', '/advertising/', '/banner', '/sponsor', '/tracking/',
                    '/track/', '/pixel', '/beacon', '/collect', '/log', '/analytics',
                ]
                
                for pattern in blocked_patterns:
                    if pattern in uri_lower:
                        blocked = True
                        break
            
            if blocked:
                try:
                    resource.cancel()
                    # Track what we blocked
                    self.privacy_stats['requests_blocked'] += 1
                    self.privacy_stats['domains_blocked'].add(domain)
                    GLib.idle_add(self.update_privacy_stats_display)
                except:
                    pass
                return
            
            # Fallback: Block ad and tracking resources
            blocked_patterns = [
                'doubleclick', 'googlesyndication', 'googleadservices',
                'adsense', 'adform', 'adnxs', 'google-analytics',
                'googletagmanager', 'facebook.net', 'scorecardresearch',
                'quantserve', '/ads/', '/advertising/', '/banner',
                '.ad.', '/ad?', '?ad=', 'advertising', 'tracking',
                'analytics', 'pixel', 'beacon', 'tracking',
            ]
            
            for pattern in blocked_patterns:
                if pattern in uri_lower:
                    try:
                        resource.cancel()
                    except:
                        pass
                    return
        except:
            pass
    
    def load_max_privacy_mode_js(self):
        """Load maximum privacy mode - makes all users identical (anti-fingerprinting)"""
        return r"""
        (function() {
            'use strict';
            
            // MAXIMUM PRIVACY MODE - Make all users appear identical
            // This prevents fingerprinting by making everyone look the same
            
            // ===== CANVAS FINGERPRINTING PROTECTION =====
            const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
            const originalToBlob = HTMLCanvasElement.prototype.toBlob;
            const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;
            
            // Add consistent noise to canvas (same for all users)
            function addCanvasNoise(imageData) {
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    // Add consistent noise based on pixel position
                    const noise = Math.sin(i * 0.1) * 0.5;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
                }
                return imageData;
            }
            
            HTMLCanvasElement.prototype.toDataURL = function() {
                const context = this.getContext('2d');
                if (context) {
                    const imageData = context.getImageData(0, 0, this.width, this.height);
                    addCanvasNoise(imageData);
                    context.putImageData(imageData, 0, 0);
                }
                return originalToDataURL.apply(this, arguments);
            };
            
            HTMLCanvasElement.prototype.toBlob = function(callback) {
                const context = this.getContext('2d');
                if (context) {
                    const imageData = context.getImageData(0, 0, this.width, this.height);
                    addCanvasNoise(imageData);
                    context.putImageData(imageData, 0, 0);
                }
                return originalToBlob.apply(this, arguments);
            };
            
            CanvasRenderingContext2D.prototype.getImageData = function() {
                const imageData = originalGetImageData.apply(this, arguments);
                return addCanvasNoise(imageData);
            };
            
            // ===== WEBGL FINGERPRINTING PROTECTION =====
            const getParameter = WebGLRenderingContext.prototype.getParameter;
            WebGLRenderingContext.prototype.getParameter = function(parameter) {
                // Return standardized values for all users
                const standardized = {
                    37445: 'Intel Inc.',           // UNMASKED_VENDOR_WEBGL
                    37446: 'Intel Iris OpenGL Engine', // UNMASKED_RENDERER_WEBGL
                    7936: 'WebGL 1.0',             // VERSION
                    7937: 'WebGL GLSL ES 1.0',     // SHADING_LANGUAGE_VERSION
                };
                return standardized[parameter] || getParameter.apply(this, arguments);
            };
            
            // ===== AUDIO FINGERPRINTING PROTECTION =====
            if (window.AudioContext || window.webkitAudioContext) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const originalCreateAnalyser = AudioContext.prototype.createAnalyser;
                const originalCreateOscillator = AudioContext.prototype.createOscillator;
                
                AudioContext.prototype.createAnalyser = function() {
                    const analyser = originalCreateAnalyser.apply(this, arguments);
                    const originalGetFloatFrequencyData = analyser.getFloatFrequencyData;
                    analyser.getFloatFrequencyData = function(array) {
                        originalGetFloatFrequencyData.apply(this, arguments);
                        // Add consistent noise
                        for (let i = 0; i < array.length; i++) {
                            array[i] += Math.sin(i * 0.1) * 0.1;
                        }
                    };
                    return analyser;
                };
            }
            
            // ===== FONT FINGERPRINTING PROTECTION =====
            // Standardize font measurements
            const originalOffsetWidth = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetWidth');
            const originalOffsetHeight = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight');
            const originalGetBoundingClientRect = Element.prototype.getBoundingClientRect;
            
            if (originalOffsetWidth && originalOffsetWidth.get) {
                Object.defineProperty(HTMLElement.prototype, 'offsetWidth', {
                    get: function() {
                        const width = originalOffsetWidth.get.call(this);
                        // Round to nearest 10 to prevent fingerprinting
                        return Math.round(width / 10) * 10;
                    },
                    configurable: true
                });
            }
            
            if (originalOffsetHeight && originalOffsetHeight.get) {
                Object.defineProperty(HTMLElement.prototype, 'offsetHeight', {
                    get: function() {
                        const height = originalOffsetHeight.get.call(this);
                        return Math.round(height / 10) * 10;
                    },
                    configurable: true
                });
            }
            
            Element.prototype.getBoundingClientRect = function() {
                const rect = originalGetBoundingClientRect.apply(this, arguments);
                // Round values to prevent fingerprinting
                return {
                    x: Math.round(rect.x / 5) * 5,
                    y: Math.round(rect.y / 5) * 5,
                    width: Math.round(rect.width / 5) * 5,
                    height: Math.round(rect.height / 5) * 5,
                    top: Math.round(rect.top / 5) * 5,
                    right: Math.round(rect.right / 5) * 5,
                    bottom: Math.round(rect.bottom / 5) * 5,
                    left: Math.round(rect.left / 5) * 5
                };
            };
            
            // ===== SCREEN FINGERPRINTING PROTECTION =====
            // Standardize screen dimensions for all users
            Object.defineProperty(window.screen, 'width', {
                get: function() { return 1920; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'height', {
                get: function() { return 1080; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'availWidth', {
                get: function() { return 1920; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'availHeight', {
                get: function() { return 1040; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'colorDepth', {
                get: function() { return 24; },
                configurable: true
            });
            Object.defineProperty(window.screen, 'pixelDepth', {
                get: function() { return 24; },
                configurable: true
            });
            
            // ===== TIMEZONE FINGERPRINTING PROTECTION =====
            const originalGetTimezoneOffset = Date.prototype.getTimezoneOffset;
            Date.prototype.getTimezoneOffset = function() {
                return 0; // UTC for all users
            };
            
            const originalToString = Date.prototype.toString;
            Date.prototype.toString = function() {
                const str = originalToString.apply(this, arguments);
                // Standardize timezone string
                return str.replace(/GMT[+-]\d+/, 'GMT+0000');
            };
            
            // ===== NAVIGATOR FINGERPRINTING PROTECTION =====
            // Standardize navigator properties
            Object.defineProperty(navigator, 'platform', {
                get: function() { return 'Linux x86_64'; },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'hardwareConcurrency', {
                get: function() { return 4; },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'deviceMemory', {
                get: function() { return 8; },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'maxTouchPoints', {
                get: function() { return 0; },
                configurable: true
            });
            
            // Standardize user agent (but keep it realistic)
            Object.defineProperty(navigator, 'userAgent', {
                get: function() { 
                    return 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';
                },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'language', {
                get: function() { return 'en-US'; },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'languages', {
                get: function() { return ['en-US', 'en']; },
                configurable: true
            });
            
            // ===== WEBRTC LEAK PROTECTION =====
            // Completely block WebRTC to prevent IP leaks
            if (window.RTCPeerConnection) {
                window.RTCPeerConnection = function() {
                    throw new Error('WebRTC blocked for maximum privacy');
                };
            }
            if (window.webkitRTCPeerConnection) {
                window.webkitRTCPeerConnection = function() {
                    throw new Error('WebRTC blocked for maximum privacy');
                };
            }
            if (window.mozRTCPeerConnection) {
                window.mozRTCPeerConnection = function() {
                    throw new Error('WebRTC blocked for maximum privacy');
                };
            }
            
            // ===== BATTERY API PROTECTION =====
            if (navigator.getBattery) {
                navigator.getBattery = function() {
                    return Promise.resolve({
                        charging: true,
                        chargingTime: 0,
                        dischargingTime: Infinity,
                        level: 1.0
                    });
                };
            }
            
            // ===== PERMISSIONS API PROTECTION =====
            if (navigator.permissions) {
                const originalQuery = navigator.permissions.query;
                navigator.permissions.query = function(descriptor) {
                    // Deny all permissions to prevent tracking
                    const deniedPermissions = ['notifications', 'geolocation', 'camera', 
                                             'microphone', 'persistent-storage', 'push'];
                    if (deniedPermissions.includes(descriptor.name)) {
                        return Promise.resolve({ state: 'denied' });
                    }
                    return originalQuery.apply(this, arguments);
                };
            }
            
            // ===== GEOLOCATION PROTECTION =====
            if (navigator.geolocation) {
                const originalGetCurrentPosition = navigator.geolocation.getCurrentPosition;
                navigator.geolocation.getCurrentPosition = function(success, error) {
                    if (error) error({ code: 1, message: 'Permission denied' });
                };
                
                const originalWatchPosition = navigator.geolocation.watchPosition;
                navigator.geolocation.watchPosition = function(success, error) {
                    if (error) error({ code: 1, message: 'Permission denied' });
                    return -1;
                };
            }
            
            // ===== MEDIA DEVICES PROTECTION =====
            if (navigator.mediaDevices) {
                const originalEnumerateDevices = navigator.mediaDevices.enumerateDevices;
                navigator.mediaDevices.enumerateDevices = function() {
                    return Promise.resolve([]); // Return empty device list
                };
                
                const originalGetUserMedia = navigator.mediaDevices.getUserMedia;
                navigator.mediaDevices.getUserMedia = function() {
                    return Promise.reject(new Error('Permission denied'));
                };
            }
            
            // ===== PLUGINS PROTECTION =====
            Object.defineProperty(navigator, 'plugins', {
                get: function() { return []; },
                configurable: true
            });
            
            Object.defineProperty(navigator, 'mimeTypes', {
                get: function() { return []; },
                configurable: true
            });
            
            // ===== CONNECTION API PROTECTION =====
            if (navigator.connection || navigator.mozConnection || navigator.webkitConnection) {
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                Object.defineProperty(connection, 'downlink', {
                    get: function() { return 10; },
                    configurable: true
                });
                Object.defineProperty(connection, 'effectiveType', {
                    get: function() { return '4g'; },
                    configurable: true
                });
                Object.defineProperty(connection, 'rtt', {
                    get: function() { return 50; },
                    configurable: true
                });
            }
            
            // ===== PERFORMANCE API PROTECTION =====
            if (window.performance && window.performance.getEntriesByType) {
                const originalGetEntriesByType = window.performance.getEntriesByType;
                window.performance.getEntriesByType = function(type) {
                    if (type === 'navigation' || type === 'resource') {
                        // Return minimal standardized data
                        return [];
                    }
                    return originalGetEntriesByType.apply(this, arguments);
                };
            }
            
            // ===== BLOCK ALL TRACKING COOKIES =====
            const originalCookieDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, 'cookie') ||
                                            Object.getOwnPropertyDescriptor(HTMLDocument.prototype, 'cookie');
            
            if (originalCookieDescriptor && originalCookieDescriptor.set) {
                Object.defineProperty(document, 'cookie', {
                    get: function() {
                        // Only return first-party cookies
                        const cookies = originalCookieDescriptor.get.call(this);
                        return cookies.split(';').filter(c => {
                            // Block known tracking cookies
                            const trackingPatterns = ['_ga', '_gid', '_gat', 'fbp', 'fbc', 
                                                     '_fbp', '_fbc', 'utm_', 'tracking'];
                            return !trackingPatterns.some(pattern => c.includes(pattern));
                        }).join(';');
                    },
                    set: function(value) {
                        // Block tracking cookies
                        const trackingPatterns = ['_ga', '_gid', '_gat', 'fbp', 'fbc', 
                                                 '_fbp', '_fbc', 'utm_', 'tracking', 'analytics'];
                        if (trackingPatterns.some(pattern => value.toLowerCase().includes(pattern))) {
                            return; // Block tracking cookie
                        }
                        return originalCookieDescriptor.set.call(this, value);
                    },
                    configurable: true
                });
            }
            
            // ===== BLOCK TRACKING STORAGE =====
            const originalSetItem = Storage.prototype.setItem;
            Storage.prototype.setItem = function(key, value) {
                const trackingPatterns = ['_ga', '_gid', '_gat', 'fbp', 'fbc', 
                                         '_fbp', '_fbc', 'utm_', 'tracking', 'analytics'];
                if (trackingPatterns.some(pattern => key.toLowerCase().includes(pattern))) {
                    return; // Block tracking storage
                }
                return originalSetItem.apply(this, arguments);
            };
            
            console.log('üõ°Ô∏è Maximum Privacy Mode Active - All users appear identical');
        })();
        """
    
    def on_download_started(self, download):
        """Handle download started event"""
        # Get download info
        uri = download.get_uri()
        suggested_filename = download.get_suggested_filename()
        
        # Create download entry
        download_info = {
            'uri': uri,
            'filename': suggested_filename or uri.split('/')[-1],
            'start_time': time.time(),
            'status': 'downloading',
            'bytes_received': 0,
            'total_bytes': 0,
            'download': download
        }
        
        self.downloads.append(download_info)
        
        # Connect to progress signal
        download.connect("received-data", self.on_download_progress)
        download.connect("finished", self.on_download_finished)
        
        # Set download destination
        downloads_dir = Path.home() / "Downloads"
        downloads_dir.mkdir(exist_ok=True)
        download_path = downloads_dir / download_info['filename']
        download.set_destination(f"file://{download_path}")
        
        print(f"‚¨áÔ∏è Download started: {download_info['filename']}")
    
    def on_download_progress(self, download, length):
        """Handle download progress"""
        for dl_info in self.downloads:
            if dl_info['download'] == download:
                dl_info['bytes_received'] += length
                total = download.get_estimated_progress() * 100 if download.get_estimated_progress() > 0 else 0
                print(f"‚¨áÔ∏è Download progress: {dl_info['filename']} - {total:.1f}%")
                break
    
    def on_download_finished(self, download):
        """Handle download finished"""
        for dl_info in self.downloads:
            if dl_info['download'] == download:
                dl_info['status'] = 'completed'
                dl_info['finish_time'] = time.time()
                print(f"‚úÖ Download completed: {dl_info['filename']}")
                break
    
    def show_downloads(self, button):
        """Show download manager dialog"""
        dialog = Gtk.Dialog(title="Download Manager", parent=self.window)
        dialog.set_default_size(600, 400)
        
        content = dialog.get_content_area()
        content.set_spacing(10)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        # Downloads list
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        
        downloads_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        
        if not self.downloads:
            no_downloads = Gtk.Label()
            no_downloads.set_text("No downloads yet")
            downloads_box.pack_start(no_downloads, False, False, 5)
        else:
            for dl_info in reversed(self.downloads):  # Show newest first
                dl_frame = Gtk.Frame()
                dl_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
                
                filename_label = Gtk.Label()
                filename_label.set_markup(f"<b>{dl_info['filename']}</b>")
                filename_label.set_halign(Gtk.Align.START)
                dl_box.pack_start(filename_label, False, False, 2)
                
                status_label = Gtk.Label()
                if dl_info['status'] == 'downloading':
                    progress = 0
                    if dl_info['download'].get_estimated_progress() > 0:
                        progress = dl_info['download'].get_estimated_progress() * 100
                    status_label.set_text(f"Status: Downloading... {progress:.1f}%")
                elif dl_info['status'] == 'completed':
                    elapsed = dl_info.get('finish_time', time.time()) - dl_info['start_time']
                    size_mb = dl_info['bytes_received'] / (1024 * 1024)
                    status_label.set_text(f"Status: Completed ({size_mb:.2f} MB in {elapsed:.1f}s)")
                else:
                    status_label.set_text(f"Status: {dl_info['status']}")
                status_label.set_halign(Gtk.Align.START)
                dl_box.pack_start(status_label, False, False, 2)
                
                dl_box.set_margin_start(10)
                dl_box.set_margin_end(10)
                dl_box.set_margin_top(5)
                dl_box.set_margin_bottom(5)
                
                dl_frame.add(dl_box)
                downloads_box.pack_start(dl_frame, False, False, 5)
        
        scroll.add(downloads_box)
        content.pack_start(scroll, True, True, 10)
        
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def create_sidebar(self):
        """Create Vivaldi-style sidebar"""
        # Sidebar header
        sidebar_header = Gtk.Label()
        sidebar_header.set_markup("<b>Sidebar</b>")
        sidebar_header.set_margin_start(10)
        sidebar_header.set_margin_top(10)
        self.sidebar.pack_start(sidebar_header, False, False, 0)
        
        # Bookmarks section
        bookmarks_section = Gtk.Label(label="‚≠ê Bookmarks")
        bookmarks_section.set_margin_start(10)
        bookmarks_section.set_margin_top(5)
        self.sidebar.pack_start(bookmarks_section, False, False, 0)
        
        # Notes section (Vivaldi)
        notes_btn = Gtk.Button(label="üìù Notes")
        notes_btn.connect("clicked", self.show_notes)
        notes_btn.set_margin_start(10)
        notes_btn.set_margin_top(5)
        self.sidebar.pack_start(notes_btn, False, False, 0)
        
        # Web Panels (Vivaldi)
        web_panels_btn = Gtk.Button(label="üåê Web Panels")
        web_panels_btn.connect("clicked", self.show_web_panels)
        web_panels_btn.set_margin_start(10)
        web_panels_btn.set_margin_top(5)
        self.sidebar.pack_start(web_panels_btn, False, False, 0)
        
        # GX Corner (Opera GX)
        gx_corner_btn = Gtk.Button(label="üéÆ GX Corner")
        gx_corner_btn.connect("clicked", self.show_gx_corner)
        gx_corner_btn.set_margin_start(10)
        gx_corner_btn.set_margin_top(5)
        self.sidebar.pack_start(gx_corner_btn, False, False, 0)
        
        # Shared with You (Safari)
        shared_btn = Gtk.Button(label="üì§ Shared with You")
        shared_btn.connect("clicked", self.show_shared_with_you)
        shared_btn.set_margin_start(10)
        shared_btn.set_margin_top(5)
        self.sidebar.pack_start(shared_btn, False, False, 0)
        
        self.sidebar.show_all()
    
    def toggle_sidebar(self, button):
        """Toggle Vivaldi-style sidebar"""
        self.sidebar_visible = not self.sidebar_visible
        self.sidebar.set_visible(self.sidebar_visible)
    
    def toggle_gaming_mode(self, button):
        """Toggle Opera GX Gaming Mode"""
        self.gaming_mode = not self.gaming_mode
        if self.gaming_mode:
            button.set_label("üéÆ GX ON")
            button.set_name("gaming-mode")
            if hasattr(self, 'resource_bar'):
                self.resource_bar.set_visible(True)
            self.apply_resource_limits()
        else:
            button.set_label("üéÆ GX")
            button.set_name("")
            if hasattr(self, 'resource_bar'):
                self.resource_bar.set_visible(False)
            self.remove_resource_limits()
    
    def apply_resource_limits(self):
        """Apply Opera GX resource limits"""
        pass
    
    def remove_resource_limits(self):
        """Remove Opera GX resource limits"""
        pass
    
    def start_resource_monitoring(self):
        """Start monitoring CPU/RAM/Network (Opera GX)"""
        def monitor():
            try:
                import psutil
                while True:
                    cpu_percent = psutil.cpu_percent(interval=1)
                    ram_percent = psutil.virtual_memory().percent
                    net_io = psutil.net_io_counters()
                    net_sent_mb = net_io.bytes_sent / (1024 * 1024)
                    net_recv_mb = net_io.bytes_recv / (1024 * 1024)
                    GLib.idle_add(self.update_resource_display, cpu_percent, ram_percent, net_sent_mb, net_recv_mb)
                    time.sleep(2)
            except ImportError:
                pass
            except:
                pass
        
        thread = threading.Thread(target=monitor, daemon=True)
        thread.start()
    
    def update_resource_display(self, cpu, ram, net_sent, net_recv):
        """Update resource monitor display"""
        if hasattr(self, 'cpu_label'):
            self.cpu_label.set_text(f"CPU: {cpu:.0f}%")
        if hasattr(self, 'ram_label'):
            self.ram_label.set_text(f"RAM: {ram:.0f}%")
        if hasattr(self, 'network_label'):
            self.network_label.set_text(f"NET: ‚Üë{net_sent:.1f}MB ‚Üì{net_recv:.1f}MB")
    
    def show_container_menu(self, button):
        """Show Firefox container selector"""
        menu = Gtk.Menu()
        for container in self.containers:
            item = Gtk.MenuItem(label=container)
            item.connect("activate", lambda w, c=container: self.set_container(c))
            menu.append(item)
        menu.show_all()
        menu.popup(None, None, None, None, 0, Gtk.get_current_event_time())
    
    def set_container(self, container_name):
        """Set Firefox container for current tab"""
        if self.current_tab:
            self.container_tabs[self.current_tab['page_num']] = container_name
            self.container_btn.set_label(f"üì¶ {container_name}")
    
    def show_shields_panel(self, button):
        """Show Brave Shields panel"""
        dialog = Gtk.Dialog(title="Brave Shields", parent=self.window)
        dialog.set_default_size(400, 300)
        content = dialog.get_content_area()
        content.set_spacing(10)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        shields_label = Gtk.Label()
        shields_label.set_markup("<b>Privacy Shields</b>")
        content.pack_start(shields_label, False, False, 10)
        
        level_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        aggressive_radio = Gtk.RadioButton(label="Aggressive (Block all trackers)")
        aggressive_radio.set_active(self.shields_level == 'aggressive')
        level_box.pack_start(aggressive_radio, False, False, 5)
        
        balanced_radio = Gtk.RadioButton.new_from_widget(aggressive_radio)
        balanced_radio.set_label("Balanced (Recommended)")
        balanced_radio.set_active(self.shields_level == 'balanced')
        level_box.pack_start(balanced_radio, False, False, 5)
        
        standard_radio = Gtk.RadioButton.new_from_widget(aggressive_radio)
        standard_radio.set_label("Standard")
        standard_radio.set_active(self.shields_level == 'standard')
        level_box.pack_start(standard_radio, False, False, 5)
        
        content.pack_start(level_box, False, False, 10)
        
        def apply_shields():
            if aggressive_radio.get_active():
                self.shields_level = 'aggressive'
            elif balanced_radio.get_active():
                self.shields_level = 'balanced'
            else:
                self.shields_level = 'standard'
        
        dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)
        apply_btn = dialog.add_button("Apply", Gtk.ResponseType.OK)
        apply_btn.connect("clicked", lambda w: apply_shields())
        dialog.show_all()
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            apply_shields()
        dialog.destroy()
    
    def toggle_reader_mode(self, button):
        """Toggle Safari Reader Mode"""
        if self.current_tab:
            self.reader_mode_available = True
            button.set_label("üìñ Reader")
    
    def show_speed_dial(self, button):
        """Show Opera Speed Dial"""
        dialog = Gtk.Dialog(title="Speed Dial", parent=self.window)
        dialog.set_default_size(800, 600)
        content = dialog.get_content_area()
        content.set_spacing(10)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        grid = Gtk.Grid()
        grid.set_column_spacing(20)
        grid.set_row_spacing(20)
        
        sites = [
            ("Google", "https://www.google.com", "üîç"),
            ("YouTube", "https://www.youtube.com", "‚ñ∂Ô∏è"),
            ("GitHub", "https://github.com", "üíª"),
            ("Reddit", "https://www.reddit.com", "üì±"),
            ("Twitter", "https://twitter.com", "üê¶"),
            ("Facebook", "https://www.facebook.com", "üë•"),
        ]
        
        row = 0
        col = 0
        for name, url, icon in sites:
            btn = Gtk.Button(label=f"{icon}\n{name}")
            btn.set_size_request(120, 100)
            btn.connect("clicked", lambda w, u=url: (self.navigate_to_url(u), dialog.destroy()))
            grid.attach(btn, col, row, 1, 1)
            col += 1
            if col >= 3:
                col = 0
                row += 1
        
        content.pack_start(grid, True, True, 0)
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def show_notes(self, button):
        """Show Vivaldi Notes"""
        dialog = Gtk.Dialog(title="Notes", parent=self.window)
        dialog.set_default_size(500, 400)
        content = dialog.get_content_area()
        scrolled = Gtk.ScrolledWindow()
        text_view = Gtk.TextView()
        text_view.set_wrap_mode(Gtk.WrapMode.WORD)
        scrolled.add(text_view)
        content.pack_start(scrolled, True, True, 0)
        
        dialog.add_button("Save", Gtk.ResponseType.OK)
        dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)
        dialog.show_all()
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            buffer = text_view.get_buffer()
            text = buffer.get_text(buffer.get_start_iter(), buffer.get_end_iter(), False)
            if text:
                self.notes.append({'text': text, 'timestamp': datetime.now().isoformat()})
        dialog.destroy()
    
    def show_web_panels(self, button):
        """Show Vivaldi Web Panels"""
        dialog = Gtk.Dialog(title="Web Panels", parent=self.window)
        dialog.set_default_size(400, 300)
        content = dialog.get_content_area()
        listbox = Gtk.ListBox()
        
        for panel in self.web_panels:
            row = Gtk.ListBoxRow()
            label = Gtk.Label(label=panel.get('name', 'Unnamed'))
            row.add(label)
            listbox.add(row)
        
        content.pack_start(listbox, True, True, 0)
        add_btn = Gtk.Button(label="Add Panel")
        add_btn.connect("clicked", lambda w: self.add_web_panel())
        content.pack_start(add_btn, False, False, 0)
        
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def add_web_panel(self):
        """Add Vivaldi Web Panel"""
        dialog = Gtk.Dialog(title="Add Web Panel", parent=self.window)
        dialog.set_default_size(400, 150)
        content = dialog.get_content_area()
        name_entry = Gtk.Entry()
        name_entry.set_placeholder_text("Panel Name")
        url_entry = Gtk.Entry()
        url_entry.set_placeholder_text("URL")
        
        content.pack_start(name_entry, False, False, 10)
        content.pack_start(url_entry, False, False, 10)
        
        dialog.add_button("Add", Gtk.ResponseType.OK)
        dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)
        dialog.show_all()
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            name = name_entry.get_text()
            url = url_entry.get_text()
            if name and url:
                self.web_panels.append({'name': name, 'url': url})
        dialog.destroy()
    
    def show_gx_corner(self, button):
        """Show Opera GX Corner"""
        dialog = Gtk.Dialog(title="GX Corner", parent=self.window)
        dialog.set_default_size(600, 500)
        content = dialog.get_content_area()
        label = Gtk.Label()
        label.set_markup("<b>üéÆ Gaming News & Deals</b>\n\nGX Corner brings you the latest gaming news, deals, and free games!")
        label.set_line_wrap(True)
        content.pack_start(label, False, False, 10)
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def show_shared_with_you(self, button):
        """Show Safari Shared with You"""
        dialog = Gtk.Dialog(title="Shared with You", parent=self.window)
        dialog.set_default_size(500, 400)
        content = dialog.get_content_area()
        label = Gtk.Label()
        label.set_markup("<b>üì§ Shared with You</b>\n\nLinks and content shared with you from other apps will appear here.")
        label.set_line_wrap(True)
        content.pack_start(label, False, False, 10)
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def update_privacy_stats_display(self):
        """Update privacy stats display in UI"""
        # This is called from blocking functions to update stats
        pass
    
    def show_privacy_dashboard(self, button):
        """Show COMPLETE GHOST MODE Privacy Dashboard"""
        dialog = Gtk.Dialog(title="üëª Ghost Mode Privacy Dashboard", parent=self.window)
        dialog.set_default_size(700, 600)
        
        content = dialog.get_content_area()
        content.set_spacing(15)
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(20)
        content.set_margin_bottom(20)
        
        # Header
        header = Gtk.Label()
        header.set_markup("<b><big>üëª COMPLETE GHOST MODE</big></b>")
        content.pack_start(header, False, False, 10)
        
        # Stats section
        stats_frame = Gtk.Frame(label="üìä Privacy Stats")
        stats_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        stats_box.set_margin_start(10)
        stats_box.set_margin_end(10)
        stats_box.set_margin_top(10)
        stats_box.set_margin_bottom(10)
        
        # Show stats
        ads_blocked = self.privacy_stats.get('ads_blocked', 0)
        trackers_blocked = self.privacy_stats.get('trackers_blocked', 0)
        cookies_blocked = self.privacy_stats.get('cookies_blocked', 0)
        requests_blocked = self.privacy_stats.get('requests_blocked', 0)
        domains_blocked = len(self.privacy_stats.get('domains_blocked', set()))
        
        stats_box.pack_start(Gtk.Label(label=f"üö´ Ads Blocked: {ads_blocked:,}"), False, False, 0)
        stats_box.pack_start(Gtk.Label(label=f"üõ°Ô∏è Trackers Blocked: {trackers_blocked:,}"), False, False, 0)
        stats_box.pack_start(Gtk.Label(label=f"üç™ Cookies Blocked: {cookies_blocked:,}"), False, False, 0)
        stats_box.pack_start(Gtk.Label(label=f"üö´ Requests Blocked: {requests_blocked:,}"), False, False, 0)
        stats_box.pack_start(Gtk.Label(label=f"üåê Domains Blocked: {domains_blocked:,}"), False, False, 0)
        
        stats_frame.add(stats_box)
        content.pack_start(stats_frame, False, False, 10)
        
        # Protection status
        protection_frame = Gtk.Frame(label="üõ°Ô∏è Active Protections")
        protection_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        protection_box.set_margin_start(10)
        protection_box.set_margin_end(10)
        protection_box.set_margin_top(10)
        protection_box.set_margin_bottom(10)
        
        protections = [
            ("‚úÖ", "Ad Blocking", self.settings.get('ad_blocking', True)),
            ("‚úÖ", "Tracking Protection", self.settings.get('tracking_protection', True)),
            ("‚úÖ", "Fingerprint Protection", self.settings.get('fingerprint_protection', True)),
            ("‚úÖ", "Cookie Blocking", self.settings.get('block_all_cookies', True)),
            ("‚úÖ", "WebRTC Leak Protection", self.settings.get('webrtc_leak_protection', True)),
            ("‚úÖ", "Camera Blocked", self.settings.get('block_camera', True)),
            ("‚úÖ", "Microphone Blocked", self.settings.get('block_microphone', True)),
            ("‚úÖ", "Geolocation Blocked", self.settings.get('block_geolocation', True)),
            ("‚úÖ", "Notifications Blocked", self.settings.get('block_notifications', True)),
            ("‚úÖ", "Font Fingerprinting Blocked", self.settings.get('block_all_fonts', True)),
        ]
        
        for icon, name, enabled in protections:
            status = "ON" if enabled else "OFF"
            label = Gtk.Label()
            label.set_markup(f"{icon} {name}: <b>{status}</b>")
            protection_box.pack_start(label, False, False, 0)
        
        protection_frame.add(protection_box)
        content.pack_start(protection_frame, False, False, 10)
        
        # Blocked domains list
        if domains_blocked > 0:
            domains_frame = Gtk.Frame(label=f"üö´ Blocked Domains ({domains_blocked})")
            scrolled = Gtk.ScrolledWindow()
            scrolled.set_min_content_height(150)
            domains_list = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
            domains_list.set_margin_start(10)
            domains_list.set_margin_end(10)
            domains_list.set_margin_top(10)
            domains_list.set_margin_bottom(10)
            
            for domain in list(self.privacy_stats.get('domains_blocked', set()))[:50]:  # Show first 50
                domain_label = Gtk.Label(label=f"  ‚Ä¢ {domain}")
                domain_label.set_xalign(0)
                domains_list.pack_start(domain_label, False, False, 0)
            
            scrolled.add(domains_list)
            domains_frame.add(scrolled)
            content.pack_start(domains_frame, True, True, 10)
        
        # Reset button
        reset_btn = Gtk.Button(label="üîÑ Reset Stats")
        reset_btn.connect("clicked", lambda w: self.reset_privacy_stats())
        content.pack_start(reset_btn, False, False, 5)
        
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        dialog.run()
        dialog.destroy()
    
    def reset_privacy_stats(self):
        """Reset privacy statistics"""
        self.privacy_stats = {
            'ads_blocked': 0,
            'trackers_blocked': 0,
            'cookies_blocked': 0,
            'scripts_blocked': 0,
            'fingerprints_prevented': 0,
            'requests_blocked': 0,
            'domains_blocked': set(),
        }
    
    def run(self):
        """Run the browser"""
        self.window.show_all()
        Gtk.main()

def main():
    """Main entry point"""
    try:
        gi.require_version('WebKit2', '4.1')
    except ValueError:
        print("‚ùå WebKit2 4.1 not found!")
        print("Install it with:")
        print("  sudo apt-get install gir1.2-webkit2-4.1")
        sys.exit(1)
    
    browser = PhazeBrowserEnhanced()
    browser.run()

if __name__ == "__main__":
    main()

